"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ensureBasicFolderStructure = exports.FxCore = void 0;
const tslib_1 = require("tslib");
const fs = tslib_1.__importStar(require("fs-extra"));
const jsonschema = tslib_1.__importStar(require("jsonschema"));
const path = tslib_1.__importStar(require("path"));
const typedi_1 = require("typedi");
const uuid = tslib_1.__importStar(require("uuid"));
const hooks_1 = require("@feathersjs/hooks");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const globalState_1 = require("../common/globalState");
const localizeUtils_1 = require("../common/localizeUtils");
const localSettingsProvider_1 = require("../common/localSettingsProvider");
const projectSettingsHelper_1 = require("../common/projectSettingsHelper");
const telemetry_1 = require("../common/telemetry");
const tools_1 = require("../common/tools");
const folder_1 = require("../folder");
const utils_1 = require("../plugins/resource/appstudio/utils/utils");
const question_1 = require("../plugins/solution/fx-solution/question");
const constants_1 = require("../plugins/solution/fx-solution/v3/constants");
const callback_1 = require("./callback");
const collaborator_1 = require("./collaborator");
const crypto_1 = require("./crypto");
const downloadSample_1 = require("./downloadSample");
const environment_1 = require("./environment");
const error_1 = require("./error");
const globalVars_1 = require("./globalVars");
const aadManifestMigration_1 = require("./middleware/aadManifestMigration");
const concurrentLocker_1 = require("./middleware/concurrentLocker");
const consolidateLocalRemote_1 = require("./middleware/consolidateLocalRemote");
const contextInjector_1 = require("./middleware/contextInjector");
const envInfoLoader_1 = require("./middleware/envInfoLoader");
const envInfoLoaderV3_1 = require("./middleware/envInfoLoaderV3");
const envInfoWriter_1 = require("./middleware/envInfoWriter");
const envInfoWriterV3_1 = require("./middleware/envInfoWriterV3");
const errorHandler_1 = require("./middleware/errorHandler");
const localSettingsLoader_1 = require("./middleware/localSettingsLoader");
const localSettingsWriter_1 = require("./middleware/localSettingsWriter");
const projectMigrator_1 = require("./middleware/projectMigrator");
const projectSettingsLoader_1 = require("./middleware/projectSettingsLoader");
const projectSettingsWriter_1 = require("./middleware/projectSettingsWriter");
const questionModel_1 = require("./middleware/questionModel");
const solutionLoader_1 = require("./middleware/solutionLoader");
const solutionLoaderV3_1 = require("./middleware/solutionLoaderV3");
const question_2 = require("./question");
const SolutionPluginContainer_1 = require("./SolutionPluginContainer");
const telemetry_2 = require("./telemetry");
const common_1 = require("../common");
const workflow_1 = require("../component/workflow");
const constants_2 = require("../plugins/resource/bot/constants");
const utils_2 = require("../component/utils");
require("../component/core");
const question_3 = require("../plugins/solution/fx-solution/question");
const questionModelV3_1 = require("./middleware/questionModelV3");
const projectVersionChecker_1 = require("./middleware/projectVersionChecker");
class FxCore {
    constructor(tools) {
        //V1,V2 questions
        this._getQuestionsForCreateProjectV2 = questionModel_1.getQuestionsForCreateProjectV2;
        this._getQuestionsForCreateProjectV3 = questionModel_1.getQuestionsForCreateProjectV3;
        this._getQuestionsForUserTask = questionModel_1.getQuestionsForUserTaskV2;
        this._getQuestions = questionModel_1.getQuestionsV2;
        //v3 questions
        this._getQuestionsForAddFeature = questionModel_1.getQuestionsForAddFeature;
        this._getQuestionsForProvision = questionModel_1.getQuestionsForProvision;
        this._getQuestionsForDeploy = questionModel_1.getQuestionsForDeploy;
        this._getQuestionsForPublish = questionModel_1.getQuestionsForPublish;
        this._getQuestionsForInit = questionModel_1.getQuestionsForInit;
        this._getQuestionsForUserTaskV3 = questionModel_1.getQuestionsForUserTaskV3;
        this.tools = tools;
        globalVars_1.setTools(tools);
        telemetry_1.TelemetryReporterInstance.telemetryReporter = tools.telemetryReporter;
    }
    /**
     * @todo this's a really primitive implement. Maybe could use Subscription Model to
     * refactor later.
     */
    on(event, callback) {
        return callback_1.CallbackRegistry.set(event, callback);
    }
    async createProject(inputs) {
        if (globalVars_1.isV3()) {
            return this.createProjectV3(inputs);
        }
        else {
            return this.createProjectV2(inputs);
        }
    }
    async createProjectV2(inputs, ctx) {
        if (!ctx) {
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("ctx for createProject"));
        }
        globalVars_1.setCurrentStage(teamsfx_api_1.Stage.create);
        inputs.stage = teamsfx_api_1.Stage.create;
        const folder = inputs[question_2.QuestionRootFolder.name];
        if (common_1.isPreviewFeaturesEnabled()) {
            const capability = inputs[question_2.CoreQuestionNames.Capabilities];
            inputs[question_2.CoreQuestionNames.Capabilities] = [capability];
        }
        const capabilities = inputs[question_2.CoreQuestionNames.Capabilities];
        if (capabilities && capabilities.includes(question_1.ExistingTabOptionItem.id)) {
            return await this.createExistingTabApp(inputs, folder, ctx);
        }
        const scratch = inputs[question_2.CoreQuestionNames.CreateFromScratch];
        let projectPath;
        const automaticNpmInstall = "automaticNpmInstall";
        if (scratch === question_2.ScratchOptionNo.id) {
            // create from sample
            const downloadRes = await downloadSample_1.downloadSample(inputs, ctx);
            if (downloadRes.isErr()) {
                return teamsfx_api_1.err(downloadRes.error);
            }
            projectPath = downloadRes.value;
        }
        else {
            // create from new
            const appName = inputs[question_2.CoreQuestionNames.AppName];
            if (undefined === appName)
                return teamsfx_api_1.err(error_1.InvalidInputError(`App Name is empty`, inputs));
            const validateResult = jsonschema.validate(appName, {
                pattern: question_2.ProjectNamePattern,
            });
            if (validateResult.errors && validateResult.errors.length > 0) {
                return teamsfx_api_1.err(error_1.InvalidInputError(`${validateResult.errors[0].message}`, inputs));
            }
            projectPath = path.join(folder, appName);
            inputs.projectPath = projectPath;
            const folderExist = await fs.pathExists(projectPath);
            if (folderExist) {
                return teamsfx_api_1.err(new error_1.ProjectFolderExistError(projectPath));
            }
            await fs.ensureDir(projectPath);
            await fs.ensureDir(path.join(projectPath, `.${teamsfx_api_1.ConfigFolderName}`));
            await fs.ensureDir(path.join(projectPath, path.join("templates", `${teamsfx_api_1.AppPackageFolderName}`)));
            const basicFolderRes = await ensureBasicFolderStructure(inputs);
            if (basicFolderRes.isErr()) {
                return teamsfx_api_1.err(basicFolderRes.error);
            }
            const projectSettings = {
                appName: appName,
                projectId: inputs.projectId ? inputs.projectId : uuid.v4(),
                version: projectSettingsHelper_1.getProjectSettingsVersion(),
                isFromSample: false,
            };
            if (inputs[question_2.CoreQuestionNames.Capabilities].includes(question_1.M365SsoLaunchPageOptionItem.id) ||
                inputs[question_2.CoreQuestionNames.Capabilities].includes(question_1.M365SearchAppOptionItem.id)) {
                projectSettings.isM365 = true;
                inputs.isM365 = true;
            }
            projectSettings.solutionSettings = {
                name: "",
                version: "1.0.0",
            };
            projectSettings.programmingLanguage = inputs[question_2.CoreQuestionNames.ProgrammingLanguage];
            ctx.projectSettings = projectSettings;
            const createEnvResult = await this.createEnvWithName(environment_1.environmentManager.getDefaultEnvName(), projectSettings, inputs);
            if (createEnvResult.isErr()) {
                return teamsfx_api_1.err(createEnvResult.error);
            }
            if (tools_1.isConfigUnifyEnabled()) {
                const createLocalEnvResult = await this.createEnvWithName(environment_1.environmentManager.getLocalEnvName(), projectSettings, inputs);
                if (createLocalEnvResult.isErr()) {
                    return teamsfx_api_1.err(createLocalEnvResult.error);
                }
            }
            const solution = await SolutionPluginContainer_1.getSolutionPluginV2ByName(inputs[question_2.CoreQuestionNames.Solution]);
            if (!solution) {
                return teamsfx_api_1.err(new error_1.LoadSolutionError());
            }
            ctx.solutionV2 = solution;
            projectSettings.solutionSettings.name = solution.name;
            const contextV2 = tools_1.createV2Context(projectSettings);
            ctx.contextV2 = contextV2;
            const scaffoldSourceCodeRes = await solution.scaffoldSourceCode(contextV2, inputs);
            if (scaffoldSourceCodeRes.isErr()) {
                return teamsfx_api_1.err(scaffoldSourceCodeRes.error);
            }
            if (capabilities && !capabilities.includes(question_1.TabSPFxItem.id)) {
                const generateResourceTemplateRes = await solution.generateResourceTemplate(contextV2, inputs);
                if (generateResourceTemplateRes.isErr()) {
                    return teamsfx_api_1.err(generateResourceTemplateRes.error);
                }
            }
            // ctx.provisionInputConfig = generateResourceTemplateRes.value;
            if (solution.createEnv) {
                inputs.copy = false;
                const createEnvRes = await solution.createEnv(contextV2, inputs);
                if (createEnvRes.isErr()) {
                    return teamsfx_api_1.err(createEnvRes.error);
                }
            }
        }
        if (inputs.platform === teamsfx_api_1.Platform.VSCode) {
            await globalState_1.globalStateUpdate(automaticNpmInstall, true);
        }
        return teamsfx_api_1.ok(projectPath);
    }
    async createExistingTabApp(inputs, folder, ctx) {
        var _a, _b;
        (_a = globalVars_1.TOOLS.telemetryReporter) === null || _a === void 0 ? void 0 : _a.sendTelemetryEvent(telemetry_2.CoreTelemetryEvent.CreateStart, {
            [telemetry_2.CoreTelemetryProperty.Component]: telemetry_2.CoreTelemetryComponentName,
            [telemetry_2.CoreTelemetryProperty.Capabilities]: question_1.ExistingTabOptionItem.id,
        });
        const appName = inputs[question_2.CoreQuestionNames.AppName];
        inputs.folder = path.join(folder, appName);
        const result = await this._init(inputs, ctx, true);
        if (result.isErr()) {
            return teamsfx_api_1.err(telemetry_2.sendErrorTelemetryThenReturnError(telemetry_2.CoreTelemetryEvent.Create, result.error, globalVars_1.TOOLS.telemetryReporter));
        }
        globalVars_1.TOOLS.ui.showMessage("info", localizeUtils_1.getLocalizedString("core.create.successNotice"), false);
        (_b = globalVars_1.TOOLS.telemetryReporter) === null || _b === void 0 ? void 0 : _b.sendTelemetryEvent(telemetry_2.CoreTelemetryEvent.Create, {
            [telemetry_2.CoreTelemetryProperty.Component]: telemetry_2.CoreTelemetryComponentName,
            [telemetry_2.CoreTelemetryProperty.Success]: telemetry_2.CoreTelemetrySuccess.Yes,
            [telemetry_2.CoreTelemetryProperty.Capabilities]: question_1.ExistingTabOptionItem.id,
        });
        return result;
    }
    async createProjectV3(inputs, ctx) {
        if (!ctx) {
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("ctx for createProject"));
        }
        globalVars_1.setCurrentStage(teamsfx_api_1.Stage.create);
        inputs.stage = teamsfx_api_1.Stage.create;
        const folder = inputs[question_2.QuestionRootFolder.name];
        if (!folder) {
            return teamsfx_api_1.err(error_1.InvalidInputError("folder is undefined"));
        }
        inputs.folder = folder;
        const scratch = inputs[question_2.CoreQuestionNames.CreateFromScratch];
        let projectPath;
        const automaticNpmInstall = "automaticNpmInstall";
        if (scratch === question_2.ScratchOptionNo.id) {
            // create from sample
            const downloadRes = await downloadSample_1.downloadSample(inputs, ctx);
            if (downloadRes.isErr()) {
                return teamsfx_api_1.err(downloadRes.error);
            }
            projectPath = downloadRes.value;
        }
        else {
            const context = utils_2.createContextV3();
            // create from new
            const appName = inputs[question_2.CoreQuestionNames.AppName];
            if (undefined === appName)
                return teamsfx_api_1.err(error_1.InvalidInputError(`App Name is empty`, inputs));
            const validateResult = jsonschema.validate(appName, {
                pattern: question_2.ProjectNamePattern,
            });
            if (validateResult.errors && validateResult.errors.length > 0) {
                return teamsfx_api_1.err(error_1.InvalidInputError(`${validateResult.errors[0].message}`, inputs));
            }
            projectPath = path.join(folder, appName);
            inputs.projectPath = projectPath;
            await workflow_1.runAction("fx.init", context, inputs);
            const feature = inputs.capabilities;
            delete inputs.folder;
            if (question_3.BotFeatureIds.includes(feature)) {
                inputs.feature = feature;
                await workflow_1.runAction("fx.addBot", context, inputs);
            }
        }
        if (inputs.platform === teamsfx_api_1.Platform.VSCode) {
            await globalState_1.globalStateUpdate(automaticNpmInstall, true);
        }
        return teamsfx_api_1.ok(projectPath);
    }
    /**
     * switch to different versions of provisionResources
     */
    async provisionResources(inputs) {
        if (globalVars_1.isV3()) {
            return this.provisionResourcesV3(inputs);
        }
        else {
            return this.provisionResourcesV2(inputs);
        }
    }
    async provisionResourcesV2(inputs, ctx) {
        globalVars_1.setCurrentStage(teamsfx_api_1.Stage.provision);
        inputs.stage = teamsfx_api_1.Stage.provision;
        if (!ctx || !ctx.solutionV2 || !ctx.contextV2 || !ctx.envInfoV2) {
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("Provision input stuff"));
        }
        const envInfo = ctx.envInfoV2;
        const result = await ctx.solutionV2.provisionResources(ctx.contextV2, inputs, envInfo, this.tools.tokenProvider);
        return result;
    }
    async provisionResourcesV3(inputs, ctx) {
        globalVars_1.setCurrentStage(teamsfx_api_1.Stage.provision);
        inputs.stage = teamsfx_api_1.Stage.provision;
        if (ctx &&
            ctx.solutionV3 &&
            ctx.contextV2 &&
            ctx.envInfoV3 &&
            ctx.solutionV3.provisionResources) {
            const res = await ctx.solutionV3.provisionResources(ctx.contextV2, inputs, ctx.envInfoV3, globalVars_1.TOOLS.tokenProvider);
            return res;
        }
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    /**
     * Only used to provision Teams app with user provided app package
     * @param inputs
     * @returns teamsAppId on provision success
     */
    async provisionTeamsAppForCLI(inputs) {
        if (!inputs.appPackagePath) {
            return teamsfx_api_1.err(error_1.InvalidInputError("appPackagePath is not defined", inputs));
        }
        const projectSettings = {
            appName: "fake",
            projectId: uuid.v4(),
        };
        const context = {
            userInteraction: globalVars_1.TOOLS.ui,
            logProvider: globalVars_1.TOOLS.logProvider,
            telemetryReporter: globalVars_1.TOOLS.telemetryReporter,
            cryptoProvider: new crypto_1.LocalCrypto(projectSettings.projectId),
            permissionRequestProvider: globalVars_1.TOOLS.permissionRequest,
            projectSetting: projectSettings,
        };
        const appStudioV3 = typedi_1.Container.get(constants_1.BuiltInFeaturePluginNames.appStudio);
        return appStudioV3.registerTeamsApp(context, inputs, environment_1.newEnvInfoV3(), globalVars_1.TOOLS.tokenProvider);
    }
    async deployArtifacts(inputs) {
        if (globalVars_1.isV3())
            return this.deployArtifactsV3(inputs);
        else
            return this.deployArtifactsV2(inputs);
    }
    async deployArtifactsV2(inputs, ctx) {
        globalVars_1.setCurrentStage(teamsfx_api_1.Stage.deploy);
        inputs.stage = teamsfx_api_1.Stage.deploy;
        if (!(ctx === null || ctx === void 0 ? void 0 : ctx.projectSettings)) {
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("deploy input stuff"));
        }
        if (projectSettingsHelper_1.isExistingTabApp(ctx.projectSettings)) {
            // existing app scenario, deploy has no effect
            return teamsfx_api_1.err(new error_1.OperationNotPermittedError("deploy"));
        }
        if (!ctx.solutionV2 || !ctx.contextV2 || !ctx.envInfoV2) {
            const name = tools_1.undefinedName([ctx, ctx === null || ctx === void 0 ? void 0 : ctx.solutionV2, ctx === null || ctx === void 0 ? void 0 : ctx.contextV2, ctx === null || ctx === void 0 ? void 0 : ctx.envInfoV2], ["ctx", "ctx.solutionV2", "ctx.contextV2", "ctx.envInfoV2"]);
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError(`Deploy input stuff: ${name}`));
        }
        if (ctx.solutionV2.deploy)
            return await ctx.solutionV2.deploy(ctx.contextV2, inputs, ctx.envInfoV2, this.tools.tokenProvider);
        else
            return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    async deployArtifactsV3(inputs, ctx) {
        globalVars_1.setCurrentStage(teamsfx_api_1.Stage.deploy);
        inputs.stage = teamsfx_api_1.Stage.deploy;
        if (ctx && ctx.solutionV3 && ctx.contextV2 && ctx.envInfoV3 && ctx.solutionV3.deploy) {
            const res = await ctx.solutionV3.deploy(ctx.contextV2, inputs, ctx.envInfoV3, globalVars_1.TOOLS.tokenProvider);
            return res;
        }
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    async localDebug(inputs) {
        inputs.env = environment_1.environmentManager.getLocalEnvName();
        if (globalVars_1.isV3())
            return this.provisionResourcesV3(inputs);
        else
            return this.localDebugV2(inputs);
    }
    async localDebugV2(inputs, ctx) {
        var _a;
        globalVars_1.setCurrentStage(teamsfx_api_1.Stage.debug);
        inputs.stage = teamsfx_api_1.Stage.debug;
        if (!(ctx === null || ctx === void 0 ? void 0 : ctx.projectSettings)) {
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("local debug input stuff"));
        }
        if (!ctx.solutionV2 || !ctx.contextV2) {
            const name = tools_1.undefinedName([ctx, ctx === null || ctx === void 0 ? void 0 : ctx.solutionV2, ctx === null || ctx === void 0 ? void 0 : ctx.contextV2], ["ctx", "ctx.solutionV2", "ctx.contextV2"]);
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError(`localDebug input stuff (${name})`));
        }
        if (!ctx.localSettings)
            ctx.localSettings = {};
        if (ctx.solutionV2.provisionLocalResource) {
            if (tools_1.isConfigUnifyEnabled() && ((_a = ctx.envInfoV2) === null || _a === void 0 ? void 0 : _a.config)) {
                ctx.envInfoV2.config.isLocalDebug = true;
            }
            const res = await ctx.solutionV2.provisionLocalResource(ctx.contextV2, inputs, ctx.localSettings, this.tools.tokenProvider, ctx.envInfoV2);
            if (res.kind === "success") {
                ctx.localSettings = res.output;
                return teamsfx_api_1.ok(teamsfx_api_1.Void);
            }
            else if (res.kind === "partialSuccess") {
                ctx.localSettings = res.output;
                return teamsfx_api_1.err(res.error);
            }
            else {
                return teamsfx_api_1.err(res.error);
            }
        }
        else {
            return teamsfx_api_1.ok(teamsfx_api_1.Void);
        }
    }
    _setEnvInfoV2(ctx) {
        if (ctx && ctx.solutionContext) {
            //workaround, compatible to api v2
            ctx.envInfoV2 = {
                envName: ctx.solutionContext.envInfo.envName,
                config: ctx.solutionContext.envInfo.config,
                state: {},
            };
            ctx.envInfoV2.state = tools_1.mapToJson(ctx.solutionContext.envInfo.state);
        }
    }
    async publishApplication(inputs) {
        if (globalVars_1.isV3())
            return this.publishApplicationV3(inputs);
        else
            return this.publishApplicationV2(inputs);
    }
    async publishApplicationV2(inputs, ctx) {
        globalVars_1.setCurrentStage(teamsfx_api_1.Stage.publish);
        inputs.stage = teamsfx_api_1.Stage.publish;
        if (!ctx || !ctx.solutionV2 || !ctx.contextV2 || !ctx.envInfoV2) {
            const name = tools_1.undefinedName([ctx, ctx === null || ctx === void 0 ? void 0 : ctx.solutionV2, ctx === null || ctx === void 0 ? void 0 : ctx.contextV2, ctx === null || ctx === void 0 ? void 0 : ctx.envInfoV2], ["ctx", "ctx.solutionV2", "ctx.contextV2", "ctx.envInfoV2"]);
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError(`publish input stuff: ${name}`));
        }
        return await ctx.solutionV2.publishApplication(ctx.contextV2, inputs, ctx.envInfoV2, this.tools.tokenProvider.appStudioToken);
    }
    async publishApplicationV3(inputs, ctx) {
        globalVars_1.setCurrentStage(teamsfx_api_1.Stage.publish);
        inputs.stage = teamsfx_api_1.Stage.publish;
        if (ctx &&
            ctx.solutionV3 &&
            ctx.contextV2 &&
            ctx.envInfoV3 &&
            ctx.solutionV3.publishApplication) {
            const res = await ctx.solutionV3.publishApplication(ctx.contextV2, inputs, ctx.envInfoV3, globalVars_1.TOOLS.tokenProvider.appStudioToken);
            return res;
        }
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    async executeUserTask(func, inputs) {
        if (globalVars_1.isV3())
            return this.executeUserTaskV3(func, inputs);
        else
            return this.executeUserTaskV2(func, inputs);
    }
    async executeUserTaskV2(func, inputs, ctx) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        globalVars_1.setCurrentStage(teamsfx_api_1.Stage.userTask);
        inputs.stage = teamsfx_api_1.Stage.userTask;
        const namespace = func.namespace;
        const array = namespace ? namespace.split("/") : [];
        if (tools_1.isConfigUnifyEnabled() &&
            inputs.env === environment_1.environmentManager.getLocalEnvName() &&
            (ctx === null || ctx === void 0 ? void 0 : ctx.envInfoV2)) {
            ctx.envInfoV2.config.isLocalDebug = true;
        }
        if ("" !== namespace && array.length > 0) {
            if (!ctx || !ctx.solutionV2 || !ctx.envInfoV2) {
                const name = tools_1.undefinedName([ctx, ctx === null || ctx === void 0 ? void 0 : ctx.solutionV2, ctx === null || ctx === void 0 ? void 0 : ctx.envInfoV2], ["ctx", "ctx.solutionV2", "ctx.envInfoV2"]);
                return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError(`executeUserTask input stuff: ${name}`));
            }
            if (!ctx.contextV2)
                ctx.contextV2 = tools_1.createV2Context(projectSettingsHelper_1.newProjectSettings());
            if (ctx.solutionV2.executeUserTask) {
                if (!ctx.localSettings)
                    ctx.localSettings = {};
                const res = await ctx.solutionV2.executeUserTask(ctx.contextV2, inputs, func, ctx.localSettings, ctx.envInfoV2, this.tools.tokenProvider);
                //for existing app
                if (res.isOk() &&
                    (func.method === "addCapability" || func.method === "addFeature") &&
                    inputs.capabilities &&
                    inputs.capabilities.length > 0) {
                    await ensureBasicFolderStructure(inputs);
                }
                // reset provisionSucceeded state for all env
                if (res.isOk() &&
                    (func.method === "addCapability" ||
                        func.method === "addResource" ||
                        func.method === "addFeature")) {
                    if (((_c = (_b = (_a = ctx.envInfoV2) === null || _a === void 0 ? void 0 : _a.state) === null || _b === void 0 ? void 0 : _b.solution) === null || _c === void 0 ? void 0 : _c.provisionSucceeded) === true ||
                        ((_f = (_e = (_d = ctx.envInfoV2) === null || _d === void 0 ? void 0 : _d.state) === null || _e === void 0 ? void 0 : _e.solution) === null || _f === void 0 ? void 0 : _f.provisionSucceeded) === "true") {
                        ctx.envInfoV2.state.solution.provisionSucceeded = false;
                    }
                    const allEnvRes = await environment_1.environmentManager.listRemoteEnvConfigs(inputs.projectPath);
                    if (allEnvRes.isOk()) {
                        for (const env of allEnvRes.value) {
                            const loadEnvRes = await envInfoLoaderV3_1.loadEnvInfoV3(inputs, ctx.projectSettings, env, false);
                            if (loadEnvRes.isOk()) {
                                const envInfo = loadEnvRes.value;
                                if (((_h = (_g = envInfo.state) === null || _g === void 0 ? void 0 : _g.solution) === null || _h === void 0 ? void 0 : _h.provisionSucceeded) === true ||
                                    ((_k = (_j = envInfo.state) === null || _j === void 0 ? void 0 : _j.solution) === null || _k === void 0 ? void 0 : _k.provisionSucceeded) === "true") {
                                    envInfo.state.solution.provisionSucceeded = false;
                                    await environment_1.environmentManager.writeEnvState(envInfo.state, inputs.projectPath, ctx.contextV2.cryptoProvider, env, true);
                                }
                            }
                        }
                    }
                }
                return res;
            }
            else
                return teamsfx_api_1.err(error_1.FunctionRouterError(func));
        }
        return teamsfx_api_1.err(error_1.FunctionRouterError(func));
    }
    async executeUserTaskV3(func, inputs, ctx) {
        if (func.method === "addFeature") {
            const feature = inputs.feature;
            if (feature === "sql") {
                const context = utils_2.createContextV3(ctx === null || ctx === void 0 ? void 0 : ctx.projectSettings);
                await workflow_1.runAction("fx.addSql", context, inputs);
                ctx.projectSettings = context.projectSetting;
            }
            else if (feature === question_1.BotOptionItem.id) {
                const context = utils_2.createContextV3(ctx === null || ctx === void 0 ? void 0 : ctx.projectSettings);
                await workflow_1.runAction("fx.addBot", context, inputs);
                ctx.projectSettings = context.projectSetting;
            }
        }
        return teamsfx_api_1.ok(undefined);
    }
    async getQuestions(stage, inputs, ctx) {
        if (!ctx)
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("getQuestions input stuff"));
        inputs.stage = teamsfx_api_1.Stage.getQuestions;
        globalVars_1.setCurrentStage(teamsfx_api_1.Stage.getQuestions);
        switch (stage) {
            case teamsfx_api_1.Stage.create:
                delete inputs.projectPath;
                return await this._getQuestionsForCreateProjectV2(inputs);
            case teamsfx_api_1.Stage.init:
                delete inputs.projectPath;
                return await this._getQuestionsForInit(inputs);
            default:
                const contextV2 = ctx.contextV2 ? ctx.contextV2 : tools_1.createV2Context(projectSettingsHelper_1.newProjectSettings());
                const solutionV2 = ctx.solutionV2 ? ctx.solutionV2 : await SolutionPluginContainer_1.getAllSolutionPluginsV2()[0];
                const envInfoV2 = ctx.envInfoV2
                    ? ctx.envInfoV2
                    : { envName: environment_1.environmentManager.getDefaultEnvName(), config: {}, state: {} };
                inputs.stage = stage;
                return await this._getQuestions(contextV2, solutionV2, stage, inputs, envInfoV2);
        }
    }
    async getQuestionsForUserTask(func, inputs, ctx) {
        if (!ctx)
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("getQuestionsForUserTask input stuff"));
        inputs.stage = teamsfx_api_1.Stage.getQuestions;
        globalVars_1.setCurrentStage(teamsfx_api_1.Stage.getQuestions);
        const contextV2 = ctx.contextV2 ? ctx.contextV2 : tools_1.createV2Context(projectSettingsHelper_1.newProjectSettings());
        const solutionV2 = ctx.solutionV2 ? ctx.solutionV2 : await SolutionPluginContainer_1.getAllSolutionPluginsV2()[0];
        const envInfoV2 = ctx.envInfoV2
            ? ctx.envInfoV2
            : { envName: environment_1.environmentManager.getDefaultEnvName(), config: {}, state: {} };
        return await this._getQuestionsForUserTask(contextV2, solutionV2, func, inputs, envInfoV2);
    }
    async getProjectConfig(inputs, ctx) {
        var _a, _b;
        if (!ctx)
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("getProjectConfig input stuff"));
        inputs.stage = teamsfx_api_1.Stage.getProjectConfig;
        globalVars_1.setCurrentStage(teamsfx_api_1.Stage.getProjectConfig);
        return teamsfx_api_1.ok({
            settings: ctx.projectSettings,
            config: (_a = ctx.solutionContext) === null || _a === void 0 ? void 0 : _a.envInfo.state,
            localSettings: (_b = ctx.solutionContext) === null || _b === void 0 ? void 0 : _b.localSettings,
        });
    }
    async getProjectConfigV3(inputs, ctx) {
        if (!ctx || !ctx.projectSettings)
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("getProjectConfigV3 input stuff"));
        if (!inputs.projectPath)
            return teamsfx_api_1.ok(undefined);
        inputs.stage = teamsfx_api_1.Stage.getProjectConfig;
        globalVars_1.setCurrentStage(teamsfx_api_1.Stage.getProjectConfig);
        const config = {
            projectSettings: ctx.projectSettings,
            envInfos: {},
        };
        const envNamesRes = await environment_1.environmentManager.listAllEnvConfigs(inputs.projectPath);
        if (envNamesRes.isErr()) {
            return teamsfx_api_1.err(envNamesRes.error);
        }
        for (const env of envNamesRes.value) {
            const result = await envInfoLoaderV3_1.loadEnvInfoV3(inputs, ctx.projectSettings, env, false);
            if (result.isErr()) {
                return teamsfx_api_1.err(result.error);
            }
            config.envInfos[env] = result.value;
        }
        return teamsfx_api_1.ok(config);
    }
    async grantPermission(inputs) {
        if (globalVars_1.isV3())
            return this.grantPermissionV3(inputs);
        else
            return this.grantPermissionV2(inputs);
    }
    async grantPermissionV2(inputs, ctx) {
        globalVars_1.setCurrentStage(teamsfx_api_1.Stage.grantPermission);
        inputs.stage = teamsfx_api_1.Stage.grantPermission;
        const projectPath = inputs.projectPath;
        if (!projectPath) {
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("projectPath"));
        }
        return ctx.solutionV2.grantPermission(ctx.contextV2, Object.assign(Object.assign({}, inputs), { projectPath: projectPath }), ctx.envInfoV2, this.tools.tokenProvider);
    }
    async grantPermissionV3(inputs, ctx) {
        globalVars_1.setCurrentStage(teamsfx_api_1.Stage.grantPermission);
        inputs.stage = teamsfx_api_1.Stage.grantPermission;
        const projectPath = inputs.projectPath;
        if (!projectPath) {
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("projectPath"));
        }
        if (ctx && ctx.contextV2 && ctx.envInfoV3) {
            const res = await collaborator_1.grantPermission(ctx.contextV2, inputs, ctx.envInfoV3, globalVars_1.TOOLS.tokenProvider);
            return res;
        }
        return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("ctx, contextV2, envInfoV3"));
    }
    async checkPermission(inputs) {
        if (globalVars_1.isV3())
            return this.checkPermissionV3(inputs);
        else
            return this.checkPermissionV2(inputs);
    }
    async checkPermissionV2(inputs, ctx) {
        globalVars_1.setCurrentStage(teamsfx_api_1.Stage.checkPermission);
        inputs.stage = teamsfx_api_1.Stage.checkPermission;
        const projectPath = inputs.projectPath;
        if (!projectPath) {
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("projectPath"));
        }
        return ctx.solutionV2.checkPermission(ctx.contextV2, Object.assign(Object.assign({}, inputs), { projectPath: projectPath }), ctx.envInfoV2, this.tools.tokenProvider);
    }
    async checkPermissionV3(inputs, ctx) {
        globalVars_1.setCurrentStage(teamsfx_api_1.Stage.checkPermission);
        inputs.stage = teamsfx_api_1.Stage.checkPermission;
        const projectPath = inputs.projectPath;
        if (!projectPath) {
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("projectPath"));
        }
        if (ctx && ctx.contextV2 && ctx.envInfoV3) {
            const res = await collaborator_1.checkPermission(ctx.contextV2, inputs, ctx.envInfoV3, globalVars_1.TOOLS.tokenProvider);
            return res;
        }
        return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("ctx, contextV2, envInfoV3"));
    }
    async listCollaborator(inputs) {
        if (globalVars_1.isV3())
            return this.listCollaboratorV3(inputs);
        else
            return this.listCollaboratorV2(inputs);
    }
    async listCollaboratorV2(inputs, ctx) {
        globalVars_1.setCurrentStage(teamsfx_api_1.Stage.listCollaborator);
        inputs.stage = teamsfx_api_1.Stage.listCollaborator;
        const projectPath = inputs.projectPath;
        if (!projectPath) {
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("projectPath"));
        }
        return ctx.solutionV2.listCollaborator(ctx.contextV2, Object.assign(Object.assign({}, inputs), { projectPath: projectPath }), ctx.envInfoV2, this.tools.tokenProvider);
    }
    async listCollaboratorV3(inputs, ctx) {
        globalVars_1.setCurrentStage(teamsfx_api_1.Stage.listCollaborator);
        inputs.stage = teamsfx_api_1.Stage.listCollaborator;
        const projectPath = inputs.projectPath;
        if (!projectPath) {
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("projectPath"));
        }
        if (ctx && ctx.contextV2 && ctx.envInfoV3) {
            const res = await collaborator_1.listCollaborator(ctx.contextV2, inputs, ctx.envInfoV3, globalVars_1.TOOLS.tokenProvider);
            return res;
        }
        return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("ctx, contextV2, envInfoV3"));
    }
    async getSelectedEnv(inputs, ctx) {
        var _a;
        return teamsfx_api_1.ok((_a = ctx === null || ctx === void 0 ? void 0 : ctx.envInfoV2) === null || _a === void 0 ? void 0 : _a.envName);
    }
    async encrypt(plaintext, inputs, ctx) {
        if (!ctx)
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("ctx"));
        if (!ctx.contextV2)
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("ctx.contextV2"));
        return ctx.contextV2.cryptoProvider.encrypt(plaintext);
    }
    async decrypt(ciphertext, inputs, ctx) {
        if (!ctx)
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("ctx"));
        if (!ctx.contextV2)
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("ctx.contextV2"));
        return ctx.contextV2.cryptoProvider.decrypt(ciphertext);
    }
    async buildArtifacts(inputs) {
        throw new error_1.TaskNotSupportError(teamsfx_api_1.Stage.build);
    }
    async createEnv(inputs, ctx) {
        if (!ctx)
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("createEnv input stuff"));
        const projectSettings = ctx.projectSettings;
        if (!projectSettings) {
            return teamsfx_api_1.ok(teamsfx_api_1.Void);
        }
        const core = ctx.self;
        const createEnvCopyInput = await envInfoLoader_1.askNewEnvironment(ctx, inputs);
        if (!createEnvCopyInput ||
            !createEnvCopyInput.targetEnvName ||
            !createEnvCopyInput.sourceEnvName) {
            return teamsfx_api_1.err(teamsfx_api_1.UserCancelError);
        }
        const createEnvResult = await this.createEnvCopy(createEnvCopyInput.targetEnvName, createEnvCopyInput.sourceEnvName, inputs, core);
        if (createEnvResult.isErr()) {
            return createEnvResult;
        }
        inputs.sourceEnvName = createEnvCopyInput.sourceEnvName;
        inputs.targetEnvName = createEnvCopyInput.targetEnvName;
        if (!ctx.solutionV2 || !ctx.contextV2)
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("ctx.solutionV2, ctx.contextV2"));
        if (ctx.solutionV2.createEnv) {
            inputs.copy = true;
            return await ctx.solutionV2.createEnv(ctx.contextV2, inputs);
        }
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    async createEnvWithName(targetEnvName, projectSettings, inputs, existingTabEndpoint) {
        let appName = projectSettings.appName;
        if (targetEnvName === environment_1.environmentManager.getLocalEnvName()) {
            appName = utils_1.getLocalAppName(appName);
        }
        const newEnvConfig = environment_1.environmentManager.newEnvConfigData(appName, existingTabEndpoint);
        const writeEnvResult = await environment_1.environmentManager.writeEnvConfig(inputs.projectPath, newEnvConfig, targetEnvName);
        if (writeEnvResult.isErr()) {
            return teamsfx_api_1.err(writeEnvResult.error);
        }
        this.tools.logProvider.debug(`[core] persist ${targetEnvName} env state to path ${writeEnvResult.value}: ${JSON.stringify(newEnvConfig)}`);
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    async createEnvCopy(targetEnvName, sourceEnvName, inputs, core) {
        // copy env config file
        const targetEnvConfigFilePath = environment_1.environmentManager.getEnvConfigPath(targetEnvName, inputs.projectPath);
        const sourceEnvConfigFilePath = environment_1.environmentManager.getEnvConfigPath(sourceEnvName, inputs.projectPath);
        try {
            await fs.copy(sourceEnvConfigFilePath, targetEnvConfigFilePath);
        }
        catch (e) {
            return teamsfx_api_1.err(error_1.CopyFileError(e));
        }
        globalVars_1.TOOLS.logProvider.debug(`[core] copy env config file for ${targetEnvName} environment to path ${targetEnvConfigFilePath}`);
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    // deprecated
    async activateEnv(inputs, ctx) {
        const env = inputs.env;
        if (!env) {
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("env"));
        }
        if (!ctx.projectSettings) {
            return teamsfx_api_1.ok(teamsfx_api_1.Void);
        }
        const envConfigs = await environment_1.environmentManager.listRemoteEnvConfigs(inputs.projectPath);
        if (envConfigs.isErr()) {
            return envConfigs;
        }
        if (envConfigs.isErr() || envConfigs.value.indexOf(env) < 0) {
            return teamsfx_api_1.err(error_1.NonExistEnvNameError(env));
        }
        const core = ctx.self;
        const solutionContext = await envInfoLoader_1.loadSolutionContext(inputs, ctx.projectSettings, env);
        if (!solutionContext.isErr()) {
            ctx.provisionInputConfig = solutionContext.value.envInfo.config;
            ctx.provisionOutputs = solutionContext.value.envInfo.state;
            ctx.envName = solutionContext.value.envInfo.envName;
        }
        this.tools.ui.showMessage("info", `[${env}] is activated.`, false);
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    async _init(inputs, ctx, isInitExistingApp = false) {
        if (!ctx) {
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("ctx for createProject"));
        }
        // validate app name
        const appName = inputs[question_2.CoreQuestionNames.AppName];
        const validateResult = jsonschema.validate(appName, {
            pattern: question_2.ProjectNamePattern,
        });
        if (validateResult.errors && validateResult.errors.length > 0) {
            return teamsfx_api_1.err(error_1.InvalidInputError("invalid app-name", inputs));
        }
        const projectPath = inputs.folder;
        if (!projectPath) {
            return teamsfx_api_1.err(error_1.InvalidInputError("projectPath is empty", inputs));
        }
        if (isInitExistingApp) {
            const folderExist = await fs.pathExists(projectPath);
            if (folderExist) {
                return teamsfx_api_1.err(new error_1.ProjectFolderExistError(projectPath));
            }
        }
        else {
            const isValid = projectSettingsHelper_1.isValidProject(projectPath);
            if (isValid) {
                return teamsfx_api_1.err(new error_1.OperationNotPermittedError("initialize a project in existing teamsfx project"));
            }
        }
        await fs.ensureDir(projectPath);
        inputs.projectPath = projectPath;
        // create ProjectSettings
        const projectSettings = projectSettingsHelper_1.newProjectSettings();
        projectSettings.appName = appName;
        ctx.projectSettings = projectSettings;
        // create folder structure
        await fs.ensureDir(path.join(projectPath, `.${teamsfx_api_1.ConfigFolderName}`));
        await fs.ensureDir(path.join(projectPath, "templates", `${teamsfx_api_1.AppPackageFolderName}`));
        const basicFolderRes = await ensureBasicFolderStructure(inputs, false);
        if (basicFolderRes.isErr()) {
            return teamsfx_api_1.err(basicFolderRes.error);
        }
        // create contextV2
        const context = tools_1.createV2Context(projectSettings);
        ctx.contextV2 = context;
        const appStudioV3 = typedi_1.Container.get(constants_1.BuiltInFeaturePluginNames.appStudio);
        // pre-check before initialize
        const preCheckResult = await this.preCheck(appStudioV3, projectPath);
        if (preCheckResult.isErr()) {
            return teamsfx_api_1.err(preCheckResult.error);
        }
        // init manifest
        const manifestInitRes = await appStudioV3.init(context, inputs);
        if (manifestInitRes.isErr())
            return teamsfx_api_1.err(manifestInitRes.error);
        const manifestAddcapRes = await appStudioV3.addCapabilities(context, inputs, [{ name: "staticTab", existingApp: true }]);
        if (manifestAddcapRes.isErr())
            return teamsfx_api_1.err(manifestAddcapRes.error);
        // create env config with existing tab's endpoint
        const endpoint = inputs[question_2.CoreQuestionNames.ExistingTabEndpoint];
        const createEnvResult = await this.createEnvWithName(environment_1.environmentManager.getDefaultEnvName(), projectSettings, inputs, isInitExistingApp ? endpoint : undefined);
        if (createEnvResult.isErr()) {
            return teamsfx_api_1.err(createEnvResult.error);
        }
        const createLocalEnvResult = await this.createEnvWithName(environment_1.environmentManager.getLocalEnvName(), projectSettings, inputs, isInitExistingApp ? endpoint : undefined);
        if (createLocalEnvResult.isErr()) {
            return teamsfx_api_1.err(createLocalEnvResult.error);
        }
        const sourceReadmePath = path.join(folder_1.getTemplatesFolder(), "core", teamsfx_api_1.DefaultReadme);
        if (await fs.pathExists(sourceReadmePath)) {
            const targetReadmePath = path.join(projectPath, teamsfx_api_1.DefaultReadme);
            await fs.copy(sourceReadmePath, targetReadmePath);
        }
        return teamsfx_api_1.ok(inputs.projectPath);
    }
    // pre-check before initialize
    async preCheck(appStudioV3, projectPath) {
        const existFiles = new Array();
        // 0. check if projectSettings.json exists
        const settingsFile = path.resolve(projectPath, `.${teamsfx_api_1.ConfigFolderName}`, "configs", teamsfx_api_1.ProjectSettingsFileName);
        if (await fs.pathExists(settingsFile)) {
            existFiles.push(settingsFile);
        }
        // 1. check if manifest templates exist
        const manifestPreCheckResult = await appStudioV3.preCheck(projectPath);
        existFiles.push(...manifestPreCheckResult);
        // 2. check if env config file exists
        const defaultEnvPath = environment_1.environmentManager.getEnvConfigPath(environment_1.environmentManager.getDefaultEnvName(), projectPath);
        if (await fs.pathExists(defaultEnvPath)) {
            existFiles.push(defaultEnvPath);
        }
        const localEnvPath = environment_1.environmentManager.getEnvConfigPath(environment_1.environmentManager.getLocalEnvName(), projectPath);
        if (await fs.pathExists(localEnvPath)) {
            existFiles.push(localEnvPath);
        }
        // 3. check if README.md exists
        const readmePath = path.join(projectPath, teamsfx_api_1.AutoGeneratedReadme);
        if (await fs.pathExists(readmePath)) {
            existFiles.push(readmePath);
        }
        if (existFiles.length > 0) {
            return teamsfx_api_1.err(new error_1.InitializedFileAlreadyExistError(existFiles.join(", ")));
        }
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    async init(inputs, ctx) {
        const result = await this._init(inputs, ctx);
        if (result.isOk()) {
            globalVars_1.TOOLS.ui.showMessage("info", localizeUtils_1.getLocalizedString("core.init.successNotice"), false);
        }
        return result;
    }
    async addFeature(inputs) {
        const context = utils_2.createContextV3();
        const feature = inputs.features;
        if (feature === question_1.BotOptionItem.id) {
            inputs.hosting = "azure-web-app";
            inputs.scenario = constants_2.TemplateProjectsScenarios.DEFAULT_SCENARIO_NAME;
        }
        await workflow_1.runAction("fx.addBot", context, inputs);
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
}
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        questionModel_1.QuestionModelMW,
        contextInjector_1.ContextInjectorMW,
        projectSettingsWriter_1.ProjectSettingsWriterMW,
        envInfoWriter_1.EnvInfoWriterMW(true),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "createProjectV2", null);
tslib_1.__decorate([
    hooks_1.hooks([errorHandler_1.ErrorHandlerMW, questionModelV3_1.QuestionModelMW_V3, contextInjector_1.ContextInjectorMW]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "createProjectV3", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        projectMigrator_1.ProjectMigratorMW,
        consolidateLocalRemote_1.ProjectConsolidateMW,
        aadManifestMigration_1.AadManifestMigrationMW,
        projectVersionChecker_1.ProjectVersionCheckerMW,
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoader_1.EnvInfoLoaderMW(false),
        solutionLoader_1.SolutionLoaderMW,
        questionModel_1.QuestionModelMW,
        contextInjector_1.ContextInjectorMW,
        projectSettingsWriter_1.ProjectSettingsWriterMW,
        envInfoWriter_1.EnvInfoWriterMW(),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "provisionResourcesV2", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        projectMigrator_1.ProjectMigratorMW,
        consolidateLocalRemote_1.ProjectConsolidateMW,
        aadManifestMigration_1.AadManifestMigrationMW,
        projectVersionChecker_1.ProjectVersionCheckerMW,
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoaderV3_1.EnvInfoLoaderMW_V3(false),
        solutionLoaderV3_1.SolutionLoaderMW_V3,
        questionModel_1.QuestionModelMW,
        contextInjector_1.ContextInjectorMW,
        projectSettingsWriter_1.ProjectSettingsWriterMW,
        envInfoWriterV3_1.EnvInfoWriterMW_V3(),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "provisionResourcesV3", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        projectMigrator_1.ProjectMigratorMW,
        consolidateLocalRemote_1.ProjectConsolidateMW,
        aadManifestMigration_1.AadManifestMigrationMW,
        projectVersionChecker_1.ProjectVersionCheckerMW,
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoader_1.EnvInfoLoaderMW(false),
        solutionLoader_1.SolutionLoaderMW,
        questionModel_1.QuestionModelMW,
        contextInjector_1.ContextInjectorMW,
        projectSettingsWriter_1.ProjectSettingsWriterMW,
        envInfoWriter_1.EnvInfoWriterMW(),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "deployArtifactsV2", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        projectMigrator_1.ProjectMigratorMW,
        consolidateLocalRemote_1.ProjectConsolidateMW,
        aadManifestMigration_1.AadManifestMigrationMW,
        projectVersionChecker_1.ProjectVersionCheckerMW,
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoaderV3_1.EnvInfoLoaderMW_V3(false),
        solutionLoaderV3_1.SolutionLoaderMW_V3,
        questionModel_1.QuestionModelMW,
        contextInjector_1.ContextInjectorMW,
        projectSettingsWriter_1.ProjectSettingsWriterMW,
        envInfoWriterV3_1.EnvInfoWriterMW_V3(),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "deployArtifactsV3", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        projectMigrator_1.ProjectMigratorMW,
        consolidateLocalRemote_1.ProjectConsolidateMW,
        aadManifestMigration_1.AadManifestMigrationMW,
        projectVersionChecker_1.ProjectVersionCheckerMW,
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoader_1.EnvInfoLoaderMW(true),
        localSettingsLoader_1.LocalSettingsLoaderMW,
        solutionLoader_1.SolutionLoaderMW,
        questionModel_1.QuestionModelMW,
        contextInjector_1.ContextInjectorMW,
        projectSettingsWriter_1.ProjectSettingsWriterMW,
        envInfoWriter_1.EnvInfoWriterMW(true),
        localSettingsWriter_1.LocalSettingsWriterMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "localDebugV2", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        projectMigrator_1.ProjectMigratorMW,
        consolidateLocalRemote_1.ProjectConsolidateMW,
        aadManifestMigration_1.AadManifestMigrationMW,
        projectVersionChecker_1.ProjectVersionCheckerMW,
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoader_1.EnvInfoLoaderMW(false),
        solutionLoader_1.SolutionLoaderMW,
        questionModel_1.QuestionModelMW,
        contextInjector_1.ContextInjectorMW,
        projectSettingsWriter_1.ProjectSettingsWriterMW,
        envInfoWriter_1.EnvInfoWriterMW(),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "publishApplicationV2", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        projectMigrator_1.ProjectMigratorMW,
        consolidateLocalRemote_1.ProjectConsolidateMW,
        aadManifestMigration_1.AadManifestMigrationMW,
        projectVersionChecker_1.ProjectVersionCheckerMW,
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoader_1.EnvInfoLoaderMW(false),
        solutionLoader_1.SolutionLoaderMW,
        questionModel_1.QuestionModelMW,
        contextInjector_1.ContextInjectorMW,
        projectSettingsWriter_1.ProjectSettingsWriterMW,
        envInfoWriter_1.EnvInfoWriterMW(),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "publishApplicationV3", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        projectMigrator_1.ProjectMigratorMW,
        consolidateLocalRemote_1.ProjectConsolidateMW,
        aadManifestMigration_1.AadManifestMigrationMW,
        projectVersionChecker_1.ProjectVersionCheckerMW,
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoader_1.EnvInfoLoaderMW(false),
        localSettingsLoader_1.LocalSettingsLoaderMW,
        solutionLoader_1.SolutionLoaderMW,
        questionModel_1.QuestionModelMW,
        contextInjector_1.ContextInjectorMW,
        projectSettingsWriter_1.ProjectSettingsWriterMW,
        envInfoWriter_1.EnvInfoWriterMW(),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "executeUserTaskV2", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        projectMigrator_1.ProjectMigratorMW,
        consolidateLocalRemote_1.ProjectConsolidateMW,
        aadManifestMigration_1.AadManifestMigrationMW,
        projectVersionChecker_1.ProjectVersionCheckerMW,
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoaderV3_1.EnvInfoLoaderMW_V3(false),
        localSettingsLoader_1.LocalSettingsLoaderMW,
        solutionLoaderV3_1.SolutionLoaderMW_V3,
        questionModelV3_1.QuestionModelMW_V3,
        contextInjector_1.ContextInjectorMW,
        projectSettingsWriter_1.ProjectSettingsWriterMW,
        envInfoWriter_1.EnvInfoWriterMW(),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "executeUserTaskV3", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoader_1.EnvInfoLoaderMW(true),
        solutionLoader_1.SolutionLoaderMW,
        contextInjector_1.ContextInjectorMW,
        envInfoWriter_1.EnvInfoWriterMW(),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "getQuestions", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoader_1.EnvInfoLoaderMW(true),
        solutionLoader_1.SolutionLoaderMW,
        contextInjector_1.ContextInjectorMW,
        envInfoWriter_1.EnvInfoWriterMW(),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "getQuestionsForUserTask", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        projectMigrator_1.ProjectMigratorMW,
        consolidateLocalRemote_1.ProjectConsolidateMW,
        aadManifestMigration_1.AadManifestMigrationMW,
        projectVersionChecker_1.ProjectVersionCheckerMW,
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoader_1.EnvInfoLoaderMW(false),
        localSettingsLoader_1.LocalSettingsLoaderMW,
        contextInjector_1.ContextInjectorMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "getProjectConfig", null);
tslib_1.__decorate([
    hooks_1.hooks([errorHandler_1.ErrorHandlerMW, concurrentLocker_1.ConcurrentLockerMW, projectSettingsLoader_1.ProjectSettingsLoaderMW, contextInjector_1.ContextInjectorMW]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "getProjectConfigV3", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        projectMigrator_1.ProjectMigratorMW,
        consolidateLocalRemote_1.ProjectConsolidateMW,
        aadManifestMigration_1.AadManifestMigrationMW,
        projectVersionChecker_1.ProjectVersionCheckerMW,
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoader_1.EnvInfoLoaderMW(false),
        solutionLoader_1.SolutionLoaderMW,
        questionModel_1.QuestionModelMW,
        contextInjector_1.ContextInjectorMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "grantPermissionV2", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        projectMigrator_1.ProjectMigratorMW,
        consolidateLocalRemote_1.ProjectConsolidateMW,
        aadManifestMigration_1.AadManifestMigrationMW,
        projectVersionChecker_1.ProjectVersionCheckerMW,
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoaderV3_1.EnvInfoLoaderMW_V3(false),
        questionModel_1.QuestionModelMW,
        contextInjector_1.ContextInjectorMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "grantPermissionV3", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        projectMigrator_1.ProjectMigratorMW,
        consolidateLocalRemote_1.ProjectConsolidateMW,
        aadManifestMigration_1.AadManifestMigrationMW,
        projectVersionChecker_1.ProjectVersionCheckerMW,
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoader_1.EnvInfoLoaderMW(false),
        solutionLoader_1.SolutionLoaderMW,
        questionModel_1.QuestionModelMW,
        contextInjector_1.ContextInjectorMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "checkPermissionV2", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        projectMigrator_1.ProjectMigratorMW,
        consolidateLocalRemote_1.ProjectConsolidateMW,
        aadManifestMigration_1.AadManifestMigrationMW,
        projectVersionChecker_1.ProjectVersionCheckerMW,
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoaderV3_1.EnvInfoLoaderMW_V3(false),
        contextInjector_1.ContextInjectorMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "checkPermissionV3", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        projectMigrator_1.ProjectMigratorMW,
        consolidateLocalRemote_1.ProjectConsolidateMW,
        aadManifestMigration_1.AadManifestMigrationMW,
        projectVersionChecker_1.ProjectVersionCheckerMW,
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoader_1.EnvInfoLoaderMW(false),
        solutionLoader_1.SolutionLoaderMW,
        questionModel_1.QuestionModelMW,
        contextInjector_1.ContextInjectorMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "listCollaboratorV2", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        projectMigrator_1.ProjectMigratorMW,
        consolidateLocalRemote_1.ProjectConsolidateMW,
        aadManifestMigration_1.AadManifestMigrationMW,
        projectVersionChecker_1.ProjectVersionCheckerMW,
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoaderV3_1.EnvInfoLoaderMW_V3(false),
        contextInjector_1.ContextInjectorMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "listCollaboratorV3", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoader_1.EnvInfoLoaderMW(false),
        contextInjector_1.ContextInjectorMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "getSelectedEnv", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoader_1.EnvInfoLoaderMW(true),
        contextInjector_1.ContextInjectorMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "encrypt", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        envInfoLoader_1.EnvInfoLoaderMW(true),
        contextInjector_1.ContextInjectorMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "decrypt", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        solutionLoader_1.SolutionLoaderMW,
        envInfoLoader_1.EnvInfoLoaderMW(true),
        contextInjector_1.ContextInjectorMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "createEnv", null);
tslib_1.__decorate([
    hooks_1.hooks([
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        projectMigrator_1.ProjectMigratorMW,
        consolidateLocalRemote_1.ProjectConsolidateMW,
        aadManifestMigration_1.AadManifestMigrationMW,
        projectVersionChecker_1.ProjectVersionCheckerMW,
        projectSettingsLoader_1.ProjectSettingsLoaderMW,
        solutionLoader_1.SolutionLoaderMW,
        contextInjector_1.ContextInjectorMW,
        projectSettingsWriter_1.ProjectSettingsWriterMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "activateEnv", null);
tslib_1.__decorate([
    hooks_1.hooks([errorHandler_1.ErrorHandlerMW, questionModel_1.QuestionModelMW, contextInjector_1.ContextInjectorMW, projectSettingsWriter_1.ProjectSettingsWriterMW]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "init", null);
tslib_1.__decorate([
    hooks_1.hooks([errorHandler_1.ErrorHandlerMW, concurrentLocker_1.ConcurrentLockerMW]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "addFeature", null);
exports.FxCore = FxCore;
async function ensureBasicFolderStructure(inputs, createPackageJson = true) {
    if (!inputs.projectPath) {
        return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("projectPath"));
    }
    try {
        if (createPackageJson) {
            const appName = inputs[question_2.CoreQuestionNames.AppName];
            if (inputs.platform !== teamsfx_api_1.Platform.VS) {
                const packageJsonFilePath = path.join(inputs.projectPath, `package.json`);
                const exists = await fs.pathExists(packageJsonFilePath);
                if (!exists) {
                    await fs.writeFile(packageJsonFilePath, JSON.stringify({
                        name: appName,
                        version: "0.0.1",
                        description: "",
                        author: "",
                        scripts: {
                            test: 'echo "Error: no test specified" && exit 1',
                        },
                        devDependencies: {
                            "@microsoft/teamsfx-cli": "1.*",
                        },
                        license: "MIT",
                    }, null, 4));
                }
            }
        }
        {
            const gitIgnoreFilePath = path.join(inputs.projectPath, `.gitignore`);
            let lines = [];
            const exists = await fs.pathExists(gitIgnoreFilePath);
            if (exists) {
                const content = await fs.readFile(gitIgnoreFilePath, { encoding: "utf8" });
                lines = content.split("\n");
                for (let i = 0; i < lines.length; ++i) {
                    lines[i] = lines[i].trim();
                }
            }
            const gitIgnoreContent = [
                "\n# TeamsFx files",
                "node_modules",
                `.${teamsfx_api_1.ConfigFolderName}/${teamsfx_api_1.InputConfigsFolderName}/${localSettingsProvider_1.localSettingsFileName}`,
                `.${teamsfx_api_1.ConfigFolderName}/${teamsfx_api_1.StatesFolderName}/*.userdata`,
                ".DS_Store",
                ".env.teamsfx.local",
                "subscriptionInfo.json",
                teamsfx_api_1.BuildFolderName,
            ];
            if (tools_1.isConfigUnifyEnabled()) {
                gitIgnoreContent.push(`.${teamsfx_api_1.ConfigFolderName}/${teamsfx_api_1.InputConfigsFolderName}/config.local.json`);
                gitIgnoreContent.push(`.${teamsfx_api_1.ConfigFolderName}/${teamsfx_api_1.StatesFolderName}/state.local.json`);
            }
            if (inputs.platform === teamsfx_api_1.Platform.VS) {
                gitIgnoreContent.push("appsettings.Development.json");
            }
            gitIgnoreContent.forEach((line) => {
                if (!lines.includes(line.trim())) {
                    lines.push(line.trim());
                }
            });
            await fs.writeFile(gitIgnoreFilePath, lines.join("\n"), { encoding: "utf8" });
        }
    }
    catch (e) {
        return teamsfx_api_1.err(error_1.WriteFileError(e));
    }
    return teamsfx_api_1.ok(null);
}
exports.ensureBasicFolderStructure = ensureBasicFolderStructure;
//# sourceMappingURL=FxCore.js.map