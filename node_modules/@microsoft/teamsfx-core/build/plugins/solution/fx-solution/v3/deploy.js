"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.deploy = exports.getQuestionsForDeploy = void 0;
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const typedi_1 = require("typedi");
const constants_1 = require("../../../../common/constants");
const executor_1 = require("../v2/executor");
const questions_1 = require("../../utils/questions");
const localizeUtils_1 = require("../../../../common/localizeUtils");
async function getQuestionsForDeploy(ctx, inputs, envInfo, tokenProvider) {
    const solutionSetting = ctx.projectSetting.solutionSettings;
    const pluginNames = solutionSetting ? solutionSetting.activeResourcePlugins : [];
    if (pluginNames.length === 0)
        return teamsfx_api_1.ok(undefined);
    const rootNode = new teamsfx_api_1.QTreeNode(questions_1.selectMultiPluginsQuestion);
    const deployOptions = [];
    const pluginPrefix = "fx-resource-";
    for (const pluginName of pluginNames) {
        if (pluginName) {
            const plugin = typedi_1.Container.get(pluginName);
            if (plugin.deploy) {
                deployOptions.push({
                    id: pluginName,
                    label: plugin.displayName || pluginName,
                    cliName: plugin.name.replace(pluginPrefix, ""),
                });
                if (plugin.getQuestionsForDeploy) {
                    const res = await plugin.getQuestionsForDeploy(ctx, inputs, envInfo, tokenProvider);
                    if (res.isErr()) {
                        return res;
                    }
                    if (res.value) {
                        const node = res.value;
                        if (node && node.data) {
                            node.condition = { contains: pluginName };
                            rootNode.addChild(node);
                        }
                    }
                }
            }
        }
    }
    questions_1.selectMultiPluginsQuestion.staticOptions = deployOptions;
    return teamsfx_api_1.ok(rootNode);
}
exports.getQuestionsForDeploy = getQuestionsForDeploy;
async function deploy(ctx, inputs, envInfo, tokenProvider, telemetryProps) {
    const solutionSetting = ctx.projectSetting.solutionSettings;
    const pluginNames = solutionSetting ? solutionSetting.activeResourcePlugins : [];
    const plugins = pluginNames
        .map((name) => typedi_1.Container.get(name))
        .filter((p) => p.deploy !== undefined);
    if (plugins.length === 0)
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    const thunks = plugins.map((plugin) => {
        return {
            pluginName: `${plugin.name}`,
            taskName: "deploy",
            thunk: () => {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                return plugin.deploy(ctx, inputs, envInfo, tokenProvider);
            },
        };
    });
    ctx.logProvider.info(localizeUtils_1.getLocalizedString("core.deploy.selectedPluginsToDeployNotice", constants_1.PluginDisplayName.Solution, JSON.stringify(thunks.map((p) => p.pluginName))));
    ctx.logProvider.info(localizeUtils_1.getLocalizedString("core.deploy.startNotice", constants_1.PluginDisplayName.Solution));
    const result = await executor_1.executeConcurrently(thunks, ctx.logProvider);
    if (result.kind === "success") {
        const msg = localizeUtils_1.getLocalizedString("core.deploy.successNotice", ctx.projectSetting.appName);
        ctx.logProvider.info(msg);
        ctx.userInteraction.showMessage("info", msg, false);
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    else {
        const msg = localizeUtils_1.getLocalizedString("core.deploy.failNotice", ctx.projectSetting.appName);
        ctx.logProvider.info(msg);
        return teamsfx_api_1.err(result.error);
    }
}
exports.deploy = deploy;
//# sourceMappingURL=deploy.js.map