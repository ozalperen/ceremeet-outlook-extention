"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.getM365TenantId = exports.askForProvisionConsent = exports.askForDeployConsent = exports.fillInAzureConfigs = exports.checkAzureSubscription = exports.provisionResources = exports.getQuestionsForProvision = void 0;
const tslib_1 = require("tslib");
const arm_resources_1 = require("@azure/arm-resources");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const lodash_1 = require("lodash");
const typedi_1 = require("typedi");
const uuid_1 = require("uuid");
const common_1 = require("../../../../common");
const constants_1 = require("../../../../common/constants");
const localizeUtils_1 = require("../../../../common/localizeUtils");
const telemetry_1 = require("../../../../common/telemetry");
const tools_1 = require("../../../../common/tools");
const arm_1 = tslib_1.__importDefault(require("../arm"));
const constants_2 = require("../constants");
const provisionLocal_1 = require("../debug/provisionLocal");
const ResourceGroupHelper_1 = require("../utils/ResourceGroupHelper");
const executor_1 = require("../v2/executor");
const constants_3 = require("./constants");
const solutionGlobalVars_1 = require("./solutionGlobalVars");
async function getQuestionsForProvision(ctx, inputs, envInfo, tokenProvider) {
    const solutionSetting = ctx.projectSetting.solutionSettings;
    const root = new teamsfx_api_1.QTreeNode({ type: "group" });
    for (const pluginName of solutionSetting.activeResourcePlugins) {
        const plugin = typedi_1.Container.get(pluginName);
        if (plugin.getQuestionsForProvision) {
            const res = await plugin.getQuestionsForProvision(ctx, inputs, envInfo, tokenProvider);
            if (res.isErr()) {
                return res;
            }
            if (res.value) {
                const node = res.value;
                if (node && node.data) {
                    root.addChild(node);
                }
            }
        }
    }
    return teamsfx_api_1.ok(root);
}
exports.getQuestionsForProvision = getQuestionsForProvision;
async function provisionResources(ctx, inputs, envInfo, tokenProvider, telemetryProps) {
    const solutionSetting = ctx.projectSetting.solutionSettings;
    // 1. check M365 tenant
    if (!envInfo.state[constants_3.BuiltInFeaturePluginNames.appStudio])
        envInfo.state[constants_3.BuiltInFeaturePluginNames.appStudio] = {};
    const teamsAppResource = envInfo.state[constants_3.BuiltInFeaturePluginNames.appStudio];
    if (!envInfo.state.solution)
        envInfo.state.solution = {};
    const solutionConfig = envInfo.state.solution;
    solutionConfig.provisionSucceeded = false;
    const tenantIdInConfig = teamsAppResource.tenantId;
    const tenantIdInTokenRes = await getM365TenantId(tokenProvider.appStudioToken);
    if (tenantIdInTokenRes.isErr()) {
        return teamsfx_api_1.err(tenantIdInTokenRes.error);
    }
    const tenantIdInToken = tenantIdInTokenRes.value;
    if (tenantIdInConfig && tenantIdInToken && tenantIdInToken !== tenantIdInConfig) {
        return teamsfx_api_1.err(new teamsfx_api_1.UserError("Solution", constants_2.SolutionError.TeamsAppTenantIdNotRight, `The signed in M365 account does not match the M365 tenant in config file for '${envInfo.envName}' environment. Please sign out and sign in with the correct M365 account.`));
    }
    if (!tenantIdInConfig) {
        teamsAppResource.tenantId = tenantIdInToken;
        solutionConfig.teamsAppTenantId = tenantIdInToken;
    }
    // 2. register teams app
    const appStudioV3 = typedi_1.Container.get(constants_3.BuiltInFeaturePluginNames.appStudio);
    const registerTeamsAppRes = await appStudioV3.registerTeamsApp(ctx, inputs, envInfo, tokenProvider);
    if (registerTeamsAppRes.isErr())
        return teamsfx_api_1.err(registerTeamsAppRes.error);
    const teamsAppId = registerTeamsAppRes.value;
    teamsAppResource.teamsAppId = teamsAppId;
    solutionGlobalVars_1.solutionGlobalVars.TeamsAppId = teamsAppId;
    if (solutionSetting) {
        // 3. check Azure configs
        if (common_1.hasAzureResource(ctx.projectSetting) && envInfo.envName !== "local") {
            // ask common question and fill in solution config
            const solutionConfigRes = await fillInAzureConfigs(ctx, inputs, envInfo, tokenProvider);
            if (solutionConfigRes.isErr()) {
                return teamsfx_api_1.err(solutionConfigRes.error);
            }
            // ask for provision consent
            const consentResult = await askForProvisionConsent(ctx, tokenProvider.azureAccountProvider, envInfo);
            if (consentResult.isErr()) {
                return teamsfx_api_1.err(consentResult.error);
            }
            // create resource group if needed
            if (solutionConfig.needCreateResourceGroup) {
                const createRgRes = await ResourceGroupHelper_1.resourceGroupHelper.createNewResourceGroup(solutionConfig.resourceGroupName, tokenProvider.azureAccountProvider, solutionConfig.subscriptionId, solutionConfig.location);
                if (createRgRes.isErr()) {
                    return teamsfx_api_1.err(createRgRes.error);
                }
            }
        }
        // 4. collect plugins and provisionResources
        const plugins = solutionSetting.activeResourcePlugins.map((p) => typedi_1.Container.get(p));
        const provisionThunks = plugins
            .filter((plugin) => !lodash_1.isUndefined(plugin.provisionResource))
            .map((plugin) => {
            return {
                pluginName: `${plugin.name}`,
                taskName: "provisionResource",
                thunk: () => {
                    if (!envInfo.state[plugin.name]) {
                        envInfo.state[plugin.name] = {};
                    }
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    return plugin.provisionResource(ctx, inputs, envInfo, tokenProvider);
                },
            };
        });
        ctx.logProvider.info(localizeUtils_1.getLocalizedString("core.provision.StartNotice", constants_1.PluginDisplayName.Solution));
        const provisionResult = await executor_1.executeConcurrently(provisionThunks, ctx.logProvider);
        if (provisionResult.kind !== "success") {
            return teamsfx_api_1.err(provisionResult.error);
        }
        ctx.logProvider.info(localizeUtils_1.getLocalizedString("core.provision.ProvisionFinishNotice", constants_1.PluginDisplayName.Solution));
        if (envInfo.envName === "local") {
            //5.1 setup local env
            const localEnvSetupResult = await provisionLocal_1.setupLocalEnvironment(ctx, inputs, envInfo);
            if (localEnvSetupResult.isErr()) {
                return teamsfx_api_1.err(localEnvSetupResult.error);
            }
        }
        else {
            //5.2 deploy arm templates for remote
            ctx.logProvider.info(localizeUtils_1.getLocalizedString("core.deployArmTemplates.StartNotice", constants_1.PluginDisplayName.Solution));
            const armRes = await arm_1.default.deployArmTemplates(ctx, inputs, envInfo, tokenProvider.azureAccountProvider);
            if (armRes.isErr()) {
                return teamsfx_api_1.err(armRes.error);
            }
            ctx.logProvider.info(localizeUtils_1.getLocalizedString("core.deployArmTemplates.SuccessNotice", constants_1.PluginDisplayName.Solution));
        }
        // 6. collect plugins and call configureResource
        const configureResourceThunks = plugins
            .filter((plugin) => !lodash_1.isUndefined(plugin.configureResource))
            .map((plugin) => {
            if (!envInfo.state[plugin.name]) {
                envInfo.state[plugin.name] = {};
            }
            return {
                pluginName: `${plugin.name}`,
                taskName: "configureResource",
                thunk: () => 
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                plugin.configureResource(ctx, inputs, envInfo, tokenProvider),
            };
        });
        const configureResourceResult = await executor_1.executeConcurrently(configureResourceThunks, ctx.logProvider);
        ctx.logProvider.info(localizeUtils_1.getLocalizedString("core.provision.configurationFinishNotice", constants_1.PluginDisplayName.Solution));
        const envStates = envInfo.state;
        if (configureResourceResult.kind !== "success") {
            const msg = localizeUtils_1.getLocalizedString("core.provision.failNotice", ctx.projectSetting.appName);
            ctx.logProvider.error(msg);
            envStates.solution.provisionSucceeded = false;
            return teamsfx_api_1.err(configureResourceResult.error);
        }
        if (envInfo.envName === "local") {
            // 7.1 config local env
            const localConfigResult = await provisionLocal_1.configLocalEnvironment(ctx, inputs, envInfo);
            if (localConfigResult.isErr()) {
                return teamsfx_api_1.err(localConfigResult.error);
            }
        }
        else {
            // 7.2 show message for remote azure provision
            const url = tools_1.getResourceGroupInPortal(envStates.solution.subscriptionId, envStates.solution.tenantId, envStates.solution.resourceGroupName);
            const msg = localizeUtils_1.getLocalizedString("core.provision.successAzure");
            if (url) {
                const title = "View Provisioned Resources";
                ctx.userInteraction.showMessage("info", msg, false, title).then((result) => {
                    const userSelected = result.isOk() ? result.value : undefined;
                    if (userSelected === title) {
                        ctx.userInteraction.openUrl(url);
                    }
                });
            }
            else {
                ctx.userInteraction.showMessage("info", msg, false);
            }
        }
    }
    //update Teams App
    const updateTeamsAppRes = await appStudioV3.updateTeamsApp(ctx, inputs, envInfo, tokenProvider);
    if (updateTeamsAppRes.isErr()) {
        return teamsfx_api_1.err(updateTeamsAppRes.error);
    }
    if (envInfo.envName !== "local") {
        const msg = localizeUtils_1.getLocalizedString("core.provision.successNotice", ctx.projectSetting.appName);
        ctx.userInteraction.showMessage("info", msg, false);
        ctx.logProvider.info(msg);
    }
    solutionConfig.provisionSucceeded = true;
    return teamsfx_api_1.ok(envInfo);
}
exports.provisionResources = provisionResources;
/**
 * make sure subscription is correct
 *
 */
async function checkAzureSubscription(ctx, envInfo, azureAccountProvider) {
    var _a;
    const subscriptionIdInConfig = ((_a = envInfo.config.azure) === null || _a === void 0 ? void 0 : _a.subscriptionId) || envInfo.state.solution.subscriptionId;
    if (!subscriptionIdInConfig) {
        const subscriptionInAccount = await azureAccountProvider.getSelectedSubscription(true);
        if (subscriptionInAccount) {
            envInfo.state.solution.subscriptionId = subscriptionInAccount.subscriptionId;
            envInfo.state.solution.subscriptionName = subscriptionInAccount.subscriptionName;
            envInfo.state.solution.tenantId = subscriptionInAccount.tenantId;
            ctx.logProvider.info(`[${constants_1.PluginDisplayName.Solution}] checkAzureSubscription pass!`);
            return teamsfx_api_1.ok(teamsfx_api_1.Void);
        }
        else {
            return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.SolutionSource, constants_2.SolutionError.SubscriptionNotFound, "Failed to select subscription"));
        }
    }
    // make sure the user is logged in
    await azureAccountProvider.getAccountCredentialAsync(true);
    // verify valid subscription (permission)
    const subscriptions = await azureAccountProvider.listSubscriptions();
    const targetSubInfo = subscriptions.find((item) => item.subscriptionId === subscriptionIdInConfig);
    if (!targetSubInfo) {
        return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.SolutionSource, constants_2.SolutionError.SubscriptionNotFound, `The subscription '${subscriptionIdInConfig}'(${envInfo.state.solution.subscriptionName}) for '${envInfo.envName}' environment is not found in the current account, please use the right Azure account or check the '${teamsfx_api_1.EnvConfigFileNameTemplate.replace(teamsfx_api_1.EnvNamePlaceholder, envInfo.envName)}' file.`));
    }
    envInfo.state.solution.subscriptionId = targetSubInfo.subscriptionId;
    envInfo.state.solution.subscriptionName = targetSubInfo.subscriptionName;
    envInfo.state.solution.tenantId = targetSubInfo.tenantId;
    ctx.logProvider.info(`[${constants_1.PluginDisplayName.Solution}] checkAzureSubscription pass!`);
    return teamsfx_api_1.ok(teamsfx_api_1.Void);
}
exports.checkAzureSubscription = checkAzureSubscription;
/**
 * Asks common questions and puts the answers in the global namespace of SolutionConfig
 *
 */
async function fillInAzureConfigs(ctx, inputs, envInfo, tokenProvider) {
    var _a, _b, _c, _d, _e, _f, _g;
    //1. check subscriptionId
    const subscriptionResult = await checkAzureSubscription(ctx, envInfo, tokenProvider.azureAccountProvider);
    if (subscriptionResult.isErr()) {
        return teamsfx_api_1.err(subscriptionResult.error);
    }
    // Note setSubscription here will change the token returned by getAccountCredentialAsync according to the subscription selected.
    // So getting azureToken needs to precede setSubscription.
    const azureToken = await tokenProvider.azureAccountProvider.getAccountCredentialAsync();
    if (azureToken === undefined) {
        return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.SolutionSource, constants_2.SolutionError.NotLoginToAzure, "Login to Azure using the Azure Account extension"));
    }
    //2. check resource group
    (_a = ctx.telemetryReporter) === null || _a === void 0 ? void 0 : _a.sendTelemetryEvent(telemetry_1.TelemetryEvent.CheckResourceGroupStart, inputs.env ? { [telemetry_1.TelemetryProperty.Env]: tools_1.getHashedEnv(inputs.env) } : {});
    const rmClient = new arm_resources_1.ResourceManagementClient(azureToken, envInfo.state.solution.subscriptionId);
    // Resource group info precedence are:
    //   0. ctx.answers, for VS targetResourceGroupName and targetResourceLocationName to create a new rg
    //   1. ctx.answers, for CLI --resource-group argument, only support existing resource group
    //   2. env config (config.{envName}.json), for user customization, only support existing resource group
    //   3. states (state.{envName}.json), for re-provision
    //   4. asking user with a popup
    const resourceGroupNameFromEnvConfig = (_b = envInfo.config.azure) === null || _b === void 0 ? void 0 : _b.resourceGroupName;
    const resourceGroupNameFromState = envInfo.state.solution.resourceGroupName;
    const resourceGroupLocationFromState = envInfo.state.solution.location;
    const appName = ctx.projectSetting.appName;
    const defaultResourceGroupName = `${lodash_1.snakeCase(appName)}${"-" + envInfo.envName}-rg`;
    let resourceGroupInfo;
    const telemetryProperties = {};
    if (inputs.env) {
        telemetryProperties[telemetry_1.TelemetryProperty.Env] = tools_1.getHashedEnv(inputs.env);
    }
    if (inputs.targetResourceGroupName) {
        const getRes = await ResourceGroupHelper_1.resourceGroupHelper.getResourceGroupInfo(inputs.targetResourceGroupName, rmClient);
        if (getRes.isErr()) {
            // support vs to create a new resource group
            if (inputs.platform === teamsfx_api_1.Platform.VS && inputs.targetResourceLocationName) {
                resourceGroupInfo = {
                    createNewResourceGroup: true,
                    name: inputs.targetResourceGroupName,
                    location: inputs.targetResourceLocationName,
                };
            }
            else
                return teamsfx_api_1.err(getRes.error);
        }
        else {
            if (!getRes.value) {
                // Currently we do not support creating resource group from command line arguments
                return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.SolutionSource, constants_2.SolutionError.ResourceGroupNotFound, `Resource group '${inputs.targetResourceGroupName}' does not exist, please specify an existing resource group.`));
            }
            telemetryProperties[telemetry_1.TelemetryProperty.CustomizeResourceGroupType] =
                telemetry_1.CustomizeResourceGroupType.CommandLine;
            resourceGroupInfo = getRes.value;
        }
    }
    else if (resourceGroupNameFromEnvConfig) {
        const resourceGroupName = resourceGroupNameFromEnvConfig;
        const getRes = await ResourceGroupHelper_1.resourceGroupHelper.getResourceGroupInfo(resourceGroupName, rmClient);
        if (getRes.isErr())
            return teamsfx_api_1.err(getRes.error);
        if (!getRes.value) {
            // Currently we do not support creating resource group by input config, so just throw an error.
            const envFile = teamsfx_api_1.EnvConfigFileNameTemplate.replace(teamsfx_api_1.EnvNamePlaceholder, inputs.envName);
            return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.SolutionSource, constants_2.SolutionError.ResourceGroupNotFound, `Resource group '${resourceGroupName}' does not exist, please check your '${envFile}' file.`));
        }
        telemetryProperties[telemetry_1.TelemetryProperty.CustomizeResourceGroupType] =
            telemetry_1.CustomizeResourceGroupType.EnvConfig;
        resourceGroupInfo = getRes.value;
    }
    else if (resourceGroupNameFromState && resourceGroupLocationFromState) {
        const checkRes = await ResourceGroupHelper_1.resourceGroupHelper.checkResourceGroupExistence(resourceGroupNameFromState, rmClient);
        if (checkRes.isErr()) {
            return teamsfx_api_1.err(checkRes.error);
        }
        const exist = checkRes.value;
        resourceGroupInfo = {
            createNewResourceGroup: !exist,
            name: resourceGroupNameFromState,
            location: resourceGroupLocationFromState,
        };
        telemetryProperties[telemetry_1.TelemetryProperty.CustomizeResourceGroupType] =
            telemetry_1.CustomizeResourceGroupType.EnvState;
    }
    else {
        const resourceGroupInfoResult = await ResourceGroupHelper_1.resourceGroupHelper.askResourceGroupInfo(ctx, inputs, tokenProvider.azureAccountProvider, rmClient, defaultResourceGroupName);
        if (resourceGroupInfoResult.isErr()) {
            return teamsfx_api_1.err(resourceGroupInfoResult.error);
        }
        resourceGroupInfo = resourceGroupInfoResult.value;
        if (resourceGroupInfo.createNewResourceGroup) {
            if (resourceGroupInfo.name === defaultResourceGroupName) {
                telemetryProperties[telemetry_1.TelemetryProperty.CustomizeResourceGroupType] =
                    telemetry_1.CustomizeResourceGroupType.InteractiveCreateDefault;
            }
            else {
                telemetryProperties[telemetry_1.TelemetryProperty.CustomizeResourceGroupType] =
                    telemetry_1.CustomizeResourceGroupType.InteractiveCreateCustomized;
            }
        }
        else {
            telemetryProperties[telemetry_1.TelemetryProperty.CustomizeResourceGroupType] =
                telemetry_1.CustomizeResourceGroupType.InteractiveUseExisting;
        }
    }
    (_c = ctx.telemetryReporter) === null || _c === void 0 ? void 0 : _c.sendTelemetryEvent(telemetry_1.TelemetryEvent.CheckResourceGroup, telemetryProperties);
    envInfo.state.solution.needCreateResourceGroup = resourceGroupInfo.createNewResourceGroup;
    envInfo.state.solution.resourceGroupName = resourceGroupInfo.name;
    envInfo.state.solution.location = resourceGroupInfo.location;
    (_d = ctx.logProvider) === null || _d === void 0 ? void 0 : _d.info(`[${constants_1.PluginDisplayName.Solution}] check resource group pass!`);
    (_e = ctx.logProvider) === null || _e === void 0 ? void 0 : _e.info(`[${constants_1.PluginDisplayName.Solution}] check teamsAppTenantId pass!`);
    //resourceNameSuffix
    const resourceNameSuffix = ((_f = envInfo.config.azure) === null || _f === void 0 ? void 0 : _f.resourceNameSuffix) ||
        envInfo.state.solution.resourceNameSuffix ||
        uuid_1.v4().substr(0, 6);
    envInfo.state.solution.resourceNameSuffix = resourceNameSuffix;
    (_g = ctx.logProvider) === null || _g === void 0 ? void 0 : _g.info(`[${constants_1.PluginDisplayName.Solution}] check resourceNameSuffix pass!`);
    return teamsfx_api_1.ok(teamsfx_api_1.Void);
}
exports.fillInAzureConfigs = fillInAzureConfigs;
async function askForDeployConsent(ctx, azureAccountProvider, envInfo) {
    var _a, _b;
    const azureToken = await azureAccountProvider.getAccountCredentialAsync();
    // Only Azure project requires this confirm dialog
    const username = azureToken.username || "";
    const subscriptionId = ((_a = envInfo.state.solution) === null || _a === void 0 ? void 0 : _a.subscriptionId) || "";
    const subscriptionName = ((_b = envInfo.state.solution) === null || _b === void 0 ? void 0 : _b.subscriptionName) || "";
    const msg = localizeUtils_1.getLocalizedString("core.deploy.confirmEnvNotice", envInfo.envName, username, subscriptionName ? subscriptionName : subscriptionId);
    const deployOption = "Deploy";
    const result = await ctx.userInteraction.showMessage("warn", msg, true, deployOption);
    const choice = (result === null || result === void 0 ? void 0 : result.isOk()) ? result.value : undefined;
    if (choice === deployOption) {
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.SolutionSource, "UserCancel", "UserCancel"));
}
exports.askForDeployConsent = askForDeployConsent;
async function askForProvisionConsent(ctx, azureAccountProvider, envInfo) {
    var _a, _b;
    const azureToken = await azureAccountProvider.getAccountCredentialAsync();
    // Only Azure project requires this confirm dialog
    const username = azureToken.username || "";
    const subscriptionId = ((_a = envInfo.state.solution) === null || _a === void 0 ? void 0 : _a.subscriptionId) || "";
    const subscriptionName = ((_b = envInfo.state.solution) === null || _b === void 0 ? void 0 : _b.subscriptionName) || "";
    const msgNew = localizeUtils_1.getLocalizedString("core.provision.confirmEnvNotice", envInfo.envName, username, subscriptionName ? subscriptionName : subscriptionId);
    const confirmRes = await ctx.userInteraction.showMessage("warn", msgNew, true, "Provision");
    const confirm = (confirmRes === null || confirmRes === void 0 ? void 0 : confirmRes.isOk()) ? confirmRes.value : undefined;
    if (confirm !== "Provision") {
        if (confirm === "Pricing calculator") {
            ctx.userInteraction.openUrl("https://azure.microsoft.com/en-us/pricing/calculator/");
        }
        return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.SolutionSource, "CancelProvision", "CancelProvision"));
    }
    return teamsfx_api_1.ok(teamsfx_api_1.Void);
}
exports.askForProvisionConsent = askForProvisionConsent;
async function getM365TenantId(appStudioTokenProvider) {
    // Just to trigger M365 login before the concurrent execution of localDebug.
    // Because concurrent execution of localDebug may getAccessToken() concurrently, which
    // causes 2 M365 logins before the token caching in common lib takes effect.
    await appStudioTokenProvider.getAccessToken();
    const appstudioTokenJson = await appStudioTokenProvider.getJsonObject();
    if (appstudioTokenJson === undefined) {
        return teamsfx_api_1.err(new teamsfx_api_1.SystemError(constants_2.SolutionSource, constants_2.SolutionError.NoAppStudioToken, localizeUtils_1.getDefaultString("error.NoAppStudioToken"), localizeUtils_1.getLocalizedString("error.NoAppStudioToken")));
    }
    const tenantIdInToken = appstudioTokenJson.tid;
    if (!tenantIdInToken || !(typeof tenantIdInToken === "string")) {
        return teamsfx_api_1.err(new teamsfx_api_1.SystemError(constants_2.SolutionSource, constants_2.SolutionError.NoTeamsAppTenantId, localizeUtils_1.getDefaultString("error.NoTeamsAppTenantId"), localizeUtils_1.getLocalizedString("error.NoTeamsAppTenantId")));
    }
    return teamsfx_api_1.ok(tenantIdInToken);
}
exports.getM365TenantId = getM365TenantId;
//# sourceMappingURL=provision.js.map