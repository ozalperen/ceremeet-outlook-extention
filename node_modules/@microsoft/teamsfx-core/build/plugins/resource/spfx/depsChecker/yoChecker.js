"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.YoChecker = void 0;
const tslib_1 = require("tslib");
const fs = tslib_1.__importStar(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const os = tslib_1.__importStar(require("os"));
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const telemetry_helper_1 = require("../utils/telemetry-helper");
const telemetryEvents_1 = require("../utils/telemetryEvents");
const error_1 = require("../error");
const cpUtils_1 = require("../../../../common/deps-checker/util/cpUtils");
const name = "yo";
const supportedVersion = "4.3.0";
const displayName = `${name}@${supportedVersion}`;
const timeout = 6 * 60 * 1000;
class YoChecker {
    constructor(logger) {
        this._logger = logger;
    }
    static getDependencyInfo() {
        return { supportedVersion: supportedVersion, displayName: displayName };
    }
    async ensureDependency(ctx) {
        telemetry_helper_1.telemetryHelper.sendSuccessEvent(ctx, telemetryEvents_1.TelemetryEvents.EnsureYoStart);
        try {
            if (!(await this.isInstalled())) {
                this._logger.info(`${displayName} not found, installing...`);
                await this.install();
                this._logger.info(`Successfully installed ${displayName}`);
            }
            telemetry_helper_1.telemetryHelper.sendSuccessEvent(ctx, telemetryEvents_1.TelemetryEvents.EnsureYo);
        }
        catch (error) {
            telemetry_helper_1.telemetryHelper.sendErrorEvent(ctx, telemetryEvents_1.TelemetryEvents.EnsureYo, error, { [telemetryEvents_1.TelemetryProperty.EnsureYoReason]: error.name });
            await this._logger.error(`Failed to install 'yo', error = '${error}'`);
            return teamsfx_api_1.err(error);
        }
        return teamsfx_api_1.ok(true);
    }
    async isInstalled() {
        let isVersionSupported = false, hasSentinel = false;
        try {
            const yoVersion = await this.queryVersion();
            isVersionSupported = yoVersion !== undefined && supportedVersion === yoVersion;
            hasSentinel = await fs.pathExists(this.getSentinelPath());
        }
        catch (error) {
            return false;
        }
        return isVersionSupported && hasSentinel;
    }
    async install() {
        this._logger.info("Checking npm...");
        if (!(await this.hasNPM())) {
            this._logger.error("Failed to find npm!");
            throw error_1.NpmNotFoundError();
        }
        else {
            const npmVersion = await this.getNPMMajorVersion();
            if (this.isWindows() && npmVersion && parseInt(npmVersion) > 6) {
                this._logger.warning(`Supported npm version is v6.x while you have v${npmVersion}.x installed. Check aka.ms/teamsfx-spfx-help for help if you met any issues.`);
            }
        }
        this._logger.info("Start installing...");
        await this.cleanup();
        await this.installYo();
        this._logger.info("Validating package...");
        if (!(await this.validate())) {
            this._logger.debug("Failed to validate yo, cleaning up...");
            await this.cleanup();
            throw error_1.DependencyValidateError(name);
        }
    }
    async getBinFolder() {
        if (this.isWindows()) {
            const npmVersion = await this.getNPMMajorVersion();
            if (npmVersion && parseInt(npmVersion) > 6) {
                return path.join(this.getDefaultInstallPath(), "node_modules", ".bin");
            }
            else {
                return this.getDefaultInstallPath();
            }
        }
        else {
            return path.join(this.getDefaultInstallPath(), "node_modules", ".bin");
        }
    }
    async validate() {
        return await this.isInstalled();
    }
    getDefaultInstallPath() {
        return path.join(os.homedir(), `.${teamsfx_api_1.ConfigFolderName}`, "bin", "spfx");
    }
    getPackagePath() {
        return path.join(this.getDefaultInstallPath(), "node_modules", "yo");
    }
    getSentinelPath() {
        return path.join(os.homedir(), `.${teamsfx_api_1.ConfigFolderName}`, "yo-sentinel");
    }
    async queryVersion() {
        var _a;
        const packagePath = path.join(this.getDefaultInstallPath(), "node_modules", "yo", "package.json");
        if (await fs.pathExists(packagePath)) {
            const packageJson = await fs.readJson(packagePath);
            return (_a = packageJson.version) !== null && _a !== void 0 ? _a : undefined;
        }
        return undefined;
    }
    async hasNPM() {
        try {
            await cpUtils_1.cpUtils.executeCommand(undefined, this._logger, { shell: true }, "npm", "--version");
            return true;
        }
        catch (error) {
            return false;
        }
    }
    async getNPMMajorVersion() {
        try {
            const output = await cpUtils_1.cpUtils.executeCommand(undefined, this._logger, { shell: true }, "npm", "--version");
            const regex = /(?<majorVersion>\d+)(\.\d+\.\d+)/;
            const match = regex.exec(output.toString());
            if (match && match.groups) {
                return match.groups.majorVersion;
            }
            else {
                return undefined;
            }
        }
        catch (error) {
            return undefined;
        }
    }
    async cleanup() {
        try {
            await fs.emptyDir(this.getPackagePath());
            await fs.remove(this.getSentinelPath());
        }
        catch (err) {
            await this._logger.error(`Failed to clean up path: ${this.getPackagePath()}, error: ${err}`);
        }
    }
    async installYo() {
        try {
            await cpUtils_1.cpUtils.executeCommand(undefined, this._logger, { timeout: timeout, shell: false }, this.getExecCommand("npm"), "install", `${name}@${supportedVersion}`, "--prefix", `${this.getDefaultInstallPath()}`, "--no-audit", "--global-style");
            await fs.ensureFile(this.getSentinelPath());
        }
        catch (error) {
            this._logger.error("Failed to execute npm install yo");
            throw error_1.NpmInstallError(error);
        }
    }
    getExecCommand(command) {
        return this.isWindows() ? `${command}.cmd` : command;
    }
    isWindows() {
        return os.type() === "Windows_NT";
    }
}
exports.YoChecker = YoChecker;
//# sourceMappingURL=yoChecker.js.map