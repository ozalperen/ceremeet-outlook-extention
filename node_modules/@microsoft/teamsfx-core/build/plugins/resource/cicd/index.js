"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CICDPluginV2 = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const result_1 = require("./result");
const plugin_1 = require("./plugin");
const errors_1 = require("./errors");
const constants_1 = require("./constants");
const typedi_1 = require("typedi");
const ResourcePluginContainer_1 = require("../../solution/fx-solution/ResourcePluginContainer");
const questions_1 = require("./questions");
const logger_1 = require("./logger");
const environment_1 = require("../../../core/environment");
const telemetry_helper_1 = require("./utils/telemetry-helper");
const localizeUtils_1 = require("../../../common/localizeUtils");
const common_1 = require("../../../common");
const error_1 = require("../../../core/error");
const existingTemplatesStat_1 = require("./utils/existingTemplatesStat");
let CICDPluginV2 = class CICDPluginV2 {
    constructor() {
        this.name = constants_1.PluginCICD.PLUGIN_NAME;
        this.displayName = constants_1.Alias.TEAMS_CICD_PLUGIN;
        this.cicdImpl = new plugin_1.CICDImpl();
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    activate(projectSettings) {
        return true;
    }
    async addCICDWorkflows(context, inputs, envInfo) {
        logger_1.Logger.setLogger(context.logProvider);
        return await this.cicdImpl.addCICDWorkflows(context, inputs, envInfo);
    }
    async getQuestionsForUserTask(ctx, inputs, func, envInfo, tokenProvider) {
        // add CI CD workflows for minimal app is not supported.
        if (inputs.platform !== teamsfx_api_1.Platform.CLI_HELP && common_1.isExistingTabApp(ctx.projectSetting)) {
            throw new error_1.NoCapabilityFoundError(teamsfx_api_1.Stage.addCiCdFlow);
        }
        const cicdWorkflowQuestions = new teamsfx_api_1.QTreeNode({
            type: "group",
        });
        const whichProvider = {
            name: questions_1.questionNames.Provider,
            type: "singleSelect",
            staticOptions: [questions_1.githubOption, questions_1.azdoOption, questions_1.jenkinsOption],
            title: localizeUtils_1.getLocalizedString("plugins.cicd.whichProvider.title"),
            default: questions_1.githubOption.id,
        };
        const whichTemplate = {
            name: questions_1.questionNames.Template,
            type: "multiSelect",
            staticOptions: [questions_1.ciOption, questions_1.cdOption, questions_1.provisionOption, questions_1.publishOption],
            title: localizeUtils_1.getLocalizedString("plugins.cicd.whichTemplate.title"),
            default: [questions_1.ciOption.id],
        };
        // TODO: add support for VS/.Net Projects.
        if (inputs.platform === teamsfx_api_1.Platform.VSCode) {
            if (!inputs.projectPath) {
                throw new errors_1.NoProjectOpenedError();
            }
            const envProfilesResult = await environment_1.environmentManager.listRemoteEnvConfigs(inputs.projectPath);
            if (envProfilesResult.isErr()) {
                throw new errors_1.InternalError([
                    localizeUtils_1.getDefaultString("error.cicd.FailedToListMultiEnv", envProfilesResult.error.message),
                    localizeUtils_1.getLocalizedString("error.cicd.FailedToListMultiEnv", envProfilesResult.error.message),
                ], envProfilesResult.error);
            }
            const existingInstance = existingTemplatesStat_1.ExistingTemplatesStat.getInstance(inputs.projectPath, envProfilesResult.value);
            // Mute this scan before there's initial scan on upper layers.
            // await existingInstance.scan();
            const whichEnvironment = {
                type: "singleSelect",
                name: questions_1.questionNames.Environment,
                title: localizeUtils_1.getLocalizedString("plugins.cicd.whichEnvironment.title"),
                staticOptions: [],
                dynamicOptions: async (inputs) => {
                    // Remove the env items in which all combinations of templates are scaffolded/existing.
                    return existingInstance.availableEnvOptions();
                },
                skipSingleOption: true,
            };
            whichProvider.dynamicOptions = async (inputs) => {
                const envName = inputs[questions_1.questionNames.Environment];
                return existingInstance.availableProviderOptions(envName);
            };
            whichTemplate.dynamicOptions = async (inputs) => {
                const envName = inputs[questions_1.questionNames.Environment];
                const provider = inputs[questions_1.questionNames.Provider];
                return existingInstance.availableTemplateOptions(envName, provider);
            };
            cicdWorkflowQuestions.addChild(new teamsfx_api_1.QTreeNode(whichEnvironment));
        }
        cicdWorkflowQuestions.addChild(new teamsfx_api_1.QTreeNode(whichProvider));
        cicdWorkflowQuestions.addChild(new teamsfx_api_1.QTreeNode(whichTemplate));
        return teamsfx_api_1.ok(cicdWorkflowQuestions);
    }
    async executeUserTask(ctx, inputs, func, localSettings, envInfo, tokenProvider) {
        if (func.method === "addCICDWorkflows") {
            return await this.runWithExceptionCatching(ctx, envInfo, () => this.addCICDWorkflows(ctx, inputs, envInfo), true, constants_1.LifecycleFuncNames.ADD_CICD_WORKFLOWS);
        }
        return teamsfx_api_1.ok(undefined);
    }
    async runWithExceptionCatching(context, envInfo, fn, sendTelemetry, name) {
        try {
            sendTelemetry &&
                telemetry_helper_1.telemetryHelper.sendStartEvent(context, envInfo, name, this.cicdImpl.commonProperties);
            const res = await fn();
            sendTelemetry &&
                telemetry_helper_1.telemetryHelper.sendResultEvent(context, envInfo, name, res, this.cicdImpl.commonProperties);
            return res;
        }
        catch (e) {
            if (e instanceof teamsfx_api_1.UserError || e instanceof teamsfx_api_1.SystemError) {
                const res = teamsfx_api_1.err(e);
                sendTelemetry &&
                    telemetry_helper_1.telemetryHelper.sendResultEvent(context, envInfo, name, res, this.cicdImpl.commonProperties);
                return res;
            }
            if (e instanceof errors_1.PluginError) {
                const result = e.errorType === errors_1.ErrorType.System
                    ? result_1.FxCICDPluginResultFactory.SystemError(e.name, [e.genDefaultMessage(), e.genMessage()], e.innerError)
                    : result_1.FxCICDPluginResultFactory.UserError(e.name, [e.genDefaultMessage(), e.genMessage()], e.showHelpLink, e.innerError);
                sendTelemetry &&
                    telemetry_helper_1.telemetryHelper.sendResultEvent(context, envInfo, name, result, this.cicdImpl.commonProperties);
                return result;
            }
            else {
                // Unrecognized Exception.
                const UnhandledErrorCode = "UnhandledError";
                sendTelemetry &&
                    telemetry_helper_1.telemetryHelper.sendResultEvent(context, envInfo, name, result_1.FxCICDPluginResultFactory.SystemError(UnhandledErrorCode, [`Got an unhandled error: ${e.message}`, `Got an unhandled error: ${e.message}`], e.innerError), this.cicdImpl.commonProperties);
                return result_1.FxCICDPluginResultFactory.SystemError(UnhandledErrorCode, e.message, e);
            }
        }
    }
};
CICDPluginV2 = tslib_1.__decorate([
    typedi_1.Service(ResourcePluginContainer_1.ResourcePluginsV2.CICDPlugin)
], CICDPluginV2);
exports.CICDPluginV2 = CICDPluginV2;
exports.default = new CICDPluginV2();
//# sourceMappingURL=index.js.map