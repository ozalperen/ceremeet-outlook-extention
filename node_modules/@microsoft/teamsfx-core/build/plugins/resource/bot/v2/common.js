"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveServiceType = exports.resolveHostType = exports.decideTemplateScenarios = exports.getTemplateInfos = void 0;
const question_1 = require("../../../solution/fx-solution/question");
const constants_1 = require("../constants");
const question_2 = require("../question");
const mapping_1 = require("./mapping");
const strings_1 = require("../resources/strings");
function getTemplateInfos(ctx, inputs) {
    const lang = mapping_1.getLanguage(ctx.projectSetting.programmingLanguage);
    const scenarios = Array.from(decideTemplateScenarios(ctx, inputs));
    const projectName = ctx.projectSetting.appName;
    return scenarios.map((scenario) => {
        return {
            group: constants_1.TemplateProjectsConstants.GROUP_NAME_BOT,
            language: lang,
            scenario: scenario,
            variables: { ProjectName: projectName },
        };
    });
}
exports.getTemplateInfos = getTemplateInfos;
function decideTemplateScenarios(ctx, inputs) {
    var _a;
    const isM365 = (_a = ctx.projectSetting) === null || _a === void 0 ? void 0 : _a.isM365;
    const templateScenarios = new Set();
    if (isM365) {
        templateScenarios.add(constants_1.TemplateProjectsScenarios.M365_SCENARIO_NAME);
        return templateScenarios;
    }
    const botScenarios = inputs === null || inputs === void 0 ? void 0 : inputs[question_1.AzureSolutionQuestionNames.Scenarios];
    if (!botScenarios || (Array.isArray(botScenarios) && botScenarios.length === 0)) {
        templateScenarios.add(constants_1.TemplateProjectsScenarios.DEFAULT_SCENARIO_NAME);
        return templateScenarios;
    }
    botScenarios.forEach((scenario) => {
        var _a;
        switch (scenario) {
            case question_1.BotScenario.CommandAndResponseBot:
                templateScenarios.add(constants_1.TemplateProjectsScenarios.COMMAND_AND_RESPONSE_SCENARIO_NAME);
                break;
            case question_1.BotScenario.NotificationBot:
                //! Will not scaffold any trigger when notificationTriggerType is undefined,
                const notificationTriggerType = (_a = inputs[constants_1.QuestionNames.BOT_HOST_TYPE_TRIGGER]) !== null && _a !== void 0 ? _a : [question_2.AppServiceOptionItem.id];
                // notificationTriggerType may be string in VS scenario
                [].concat(notificationTriggerType).forEach((triggerType) => {
                    mapping_1.getTriggerScenarios(triggerType).forEach((item) => templateScenarios.add(item));
                });
                break;
        }
    });
    return templateScenarios;
}
exports.decideTemplateScenarios = decideTemplateScenarios;
function resolveHostType(inputs) {
    const notificationTriggerType = inputs[constants_1.QuestionNames.BOT_HOST_TYPE_TRIGGER];
    let hostType;
    if (Array.isArray(notificationTriggerType)) {
        const hostTypes = notificationTriggerType.map((item) => { var _a; return (_a = question_2.HostTypeTriggerOptions.find((option) => option.id === item)) === null || _a === void 0 ? void 0 : _a.hostType; });
        hostType = hostTypes ? hostTypes[0] : undefined;
    }
    return hostType ? hostType : strings_1.HostTypes.APP_SERVICE;
}
exports.resolveHostType = resolveHostType;
function resolveServiceType(ctx) {
    var _a, _b, _c;
    const rawHostType = (_c = (_b = (_a = ctx.projectSetting) === null || _a === void 0 ? void 0 : _a.pluginSettings) === null || _b === void 0 ? void 0 : _b[strings_1.PluginBot.PLUGIN_NAME]) === null || _c === void 0 ? void 0 : _c[strings_1.PluginBot.HOST_TYPE];
    return mapping_1.getServiceType(rawHostType);
}
exports.resolveServiceType = resolveServiceType;
//# sourceMappingURL=common.js.map