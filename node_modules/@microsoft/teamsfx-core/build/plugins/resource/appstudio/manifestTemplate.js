"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.deleteCapability = exports.updateCapability = exports.addCapabilities = exports.capabilityExceedLimit = exports.getCapabilities = exports.saveManifest = exports.loadManifest = exports.init = exports.getManifestTemplatePath = void 0;
const tslib_1 = require("tslib");
const fs = tslib_1.__importStar(require("fs-extra"));
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const common_1 = require("../../../common");
const errors_1 = require("./errors");
const results_1 = require("./results");
const constants_1 = require("./constants");
const utils_1 = require("./utils/utils");
const question_1 = require("../../solution/fx-solution/question");
async function getManifestTemplatePath(projectRoot, isLocalDebug = false) {
    const appDir = await common_1.getAppDirectory(projectRoot);
    if (common_1.isConfigUnifyEnabled()) {
        return `${appDir}/${constants_1.MANIFEST_TEMPLATE_CONSOLIDATE}`;
    }
    else {
        return isLocalDebug ? `${appDir}/${constants_1.MANIFEST_LOCAL}` : `${appDir}/${constants_1.MANIFEST_TEMPLATE}`;
    }
}
exports.getManifestTemplatePath = getManifestTemplatePath;
async function init(projectRoot, appName, existingApp) {
    const newAppPackageFolder = `${projectRoot}/templates/${teamsfx_api_1.AppPackageFolderName}`;
    await fs.ensureDir(newAppPackageFolder);
    if (common_1.isConfigUnifyEnabled()) {
        const manifestString = constants_1.TEAMS_APP_MANIFEST_TEMPLATE_V3;
        const manifest = JSON.parse(manifestString);
        if (existingApp) {
            manifest.developer = {
                name: "Teams App, Inc.",
                websiteUrl: constants_1.DEFAULT_DEVELOPER_WEBSITE_URL,
                privacyUrl: constants_1.DEFAULT_DEVELOPER_PRIVACY_URL,
                termsOfUseUrl: constants_1.DEFAULT_DEVELOPER_TERM_OF_USE_URL,
            };
        }
        await saveManifest(projectRoot, manifest);
    }
    else {
        let localManifestString = constants_1.TEAMS_APP_MANIFEST_TEMPLATE_LOCAL_DEBUG_V3;
        const suffix = "-local-debug";
        let localAppName = appName;
        if (suffix.length + appName.length <= constants_1.TEAMS_APP_SHORT_NAME_MAX_LENGTH) {
            localAppName = localAppName + suffix;
        }
        localManifestString = utils_1.replaceConfigValue(localManifestString, "appName", localAppName);
        const localManifest = JSON.parse(localManifestString);
        await saveManifest(projectRoot, localManifest, true);
        const remoteManifestString = constants_1.TEAMS_APP_MANIFEST_TEMPLATE_V3;
        const remoteManifest = JSON.parse(remoteManifestString);
        await saveManifest(projectRoot, remoteManifest, false);
    }
    return teamsfx_api_1.ok(undefined);
}
exports.init = init;
async function loadManifest(projectRoot, isLocalDebug = false) {
    const manifestFilePath = await getManifestTemplatePath(projectRoot, isLocalDebug);
    if (!(await fs.pathExists(manifestFilePath))) {
        return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(manifestFilePath)));
    }
    try {
        const manifest = await fs.readJson(manifestFilePath);
        return teamsfx_api_1.ok(manifest);
    }
    catch (e) {
        if (e.stack && e.stack.startsWith("SyntaxError")) {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ManifestLoadFailedError.name, errors_1.AppStudioError.ManifestLoadFailedError.message(`Failed to load manifest file from ${manifestFilePath}, due to ${e.message}`)));
        }
        return teamsfx_api_1.err(results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.ManifestLoadFailedError.name, errors_1.AppStudioError.ManifestLoadFailedError.message(`Failed to load manifest file from ${manifestFilePath}, due to ${e.message}`)));
    }
}
exports.loadManifest = loadManifest;
async function saveManifest(projectRoot, manifest, isLocalDebug = false) {
    const manifestFilePath = await getManifestTemplatePath(projectRoot, isLocalDebug);
    await fs.writeFile(manifestFilePath, JSON.stringify(manifest, null, 4));
    return teamsfx_api_1.ok(manifestFilePath);
}
exports.saveManifest = saveManifest;
/**
 * Only works for manifest.template.json
 * @param projectRoot
 * @returns
 */
async function getCapabilities(projectRoot) {
    if (!common_1.isConfigUnifyEnabled())
        return teamsfx_api_1.ok([]);
    const manifestRes = await loadManifest(projectRoot);
    if (manifestRes.isErr()) {
        return teamsfx_api_1.err(manifestRes.error);
    }
    const capabilities = [];
    if (manifestRes.value.staticTabs && manifestRes.value.staticTabs.length > 0) {
        capabilities.push("staticTab");
    }
    if (manifestRes.value.configurableTabs && manifestRes.value.configurableTabs.length > 0) {
        capabilities.push("configurableTab");
    }
    if (manifestRes.value.bots && manifestRes.value.bots.length > 0) {
        capabilities.push("Bot");
    }
    if (manifestRes.value.composeExtensions) {
        capabilities.push("MessageExtension");
    }
    return teamsfx_api_1.ok(capabilities);
}
exports.getCapabilities = getCapabilities;
async function capabilityExceedLimit(projectRoot, capability) {
    const localManifest = await loadManifest(projectRoot, true);
    if (localManifest.isErr()) {
        return teamsfx_api_1.err(localManifest.error);
    }
    const remoteManifest = await loadManifest(projectRoot, false);
    if (remoteManifest.isErr()) {
        return teamsfx_api_1.err(remoteManifest.error);
    }
    let localExceed, remoteExceed = false;
    switch (capability) {
        case "staticTab":
            localExceed =
                localManifest.value.staticTabs !== undefined &&
                    localManifest.value.staticTabs.length >= constants_1.STATIC_TABS_MAX_ITEMS;
            remoteExceed =
                remoteManifest.value.staticTabs !== undefined &&
                    remoteManifest.value.staticTabs.length >= constants_1.STATIC_TABS_MAX_ITEMS;
            return teamsfx_api_1.ok(localExceed || remoteExceed);
        case "configurableTab":
            localExceed =
                localManifest.value.configurableTabs !== undefined &&
                    localManifest.value.configurableTabs.length >= 1;
            remoteExceed =
                remoteManifest.value.configurableTabs !== undefined &&
                    remoteManifest.value.configurableTabs.length >= 1;
            return teamsfx_api_1.ok(localExceed || remoteExceed);
        case "Bot":
            localExceed = localManifest.value.bots !== undefined && localManifest.value.bots.length >= 1;
            remoteExceed =
                remoteManifest.value.bots !== undefined && remoteManifest.value.bots.length >= 1;
            return teamsfx_api_1.ok(localExceed || remoteExceed);
        case "MessageExtension":
            localExceed =
                localManifest.value.composeExtensions !== undefined &&
                    localManifest.value.composeExtensions.length >= 1;
            remoteExceed =
                remoteManifest.value.composeExtensions !== undefined &&
                    remoteManifest.value.composeExtensions.length >= 1;
            return teamsfx_api_1.ok(localExceed || remoteExceed);
        case "WebApplicationInfo":
            return teamsfx_api_1.ok(false);
        default:
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.InvalidCapabilityError.name, errors_1.AppStudioError.InvalidCapabilityError.message(capability)));
    }
}
exports.capabilityExceedLimit = capabilityExceedLimit;
async function addCapabilities(projectRoot, capabilities, inputs) {
    var _a, _b, _c, _d;
    const remoteManifestRes = await loadManifest(projectRoot, false);
    if (remoteManifestRes.isErr()) {
        return teamsfx_api_1.err(remoteManifestRes.error);
    }
    const remoteManifest = remoteManifestRes.value;
    let staticTabIndex = (_b = (_a = remoteManifest.staticTabs) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
    capabilities.map((capability) => {
        switch (capability.name) {
            case "staticTab":
                if (!remoteManifest.staticTabs) {
                    Object.assign(remoteManifest, { staticTabs: [] });
                }
                if (capability.snippet) {
                    remoteManifest.staticTabs.push(capability.snippet);
                }
                else {
                    if (capability.existingApp) {
                        const template = common_1.deepCopy(constants_1.STATIC_TABS_TPL_EXISTING_APP[0]);
                        template.entityId = "index" + staticTabIndex;
                        remoteManifest.staticTabs.push(template);
                    }
                    else {
                        const template = common_1.deepCopy(constants_1.STATIC_TABS_TPL_FOR_MULTI_ENV[0]);
                        template.entityId = "index" + staticTabIndex;
                        remoteManifest.staticTabs.push(template);
                    }
                    staticTabIndex++;
                }
                break;
            case "configurableTab":
                if (!remoteManifest.configurableTabs) {
                    Object.assign(remoteManifest, { configurableTabs: [] });
                }
                if (capability.snippet) {
                    remoteManifest.configurableTabs.push(capability.snippet);
                }
                else {
                    if (capability.existingApp) {
                        remoteManifest.configurableTabs = remoteManifest.configurableTabs.concat(constants_1.CONFIGURABLE_TABS_TPL_EXISTING_APP);
                    }
                    else {
                        remoteManifest.configurableTabs = remoteManifest.configurableTabs.concat(constants_1.CONFIGURABLE_TABS_TPL_FOR_MULTI_ENV);
                    }
                }
                break;
            case "Bot":
                if (!remoteManifest.bots) {
                    Object.assign(remoteManifest, { bots: [] });
                }
                if (capability.snippet) {
                    remoteManifest.bots.push(capability.snippet);
                }
                else {
                    if (capability.existingApp) {
                        remoteManifest.bots = remoteManifest.bots.concat(constants_1.BOTS_TPL_EXISTING_APP);
                    }
                    else {
                        if (remoteManifest.bots === undefined) {
                            remoteManifest.bots = [];
                        }
                        if (common_1.isBotNotificationEnabled()) {
                            const scenariosRaw = inputs[question_1.AzureSolutionQuestionNames.Scenarios];
                            const scenarios = Array.isArray(scenariosRaw) ? scenariosRaw : [];
                            if (scenarios.includes(question_1.BotScenario.CommandAndResponseBot)) {
                                // command and response bot
                                remoteManifest.bots = remoteManifest.bots.concat(constants_1.BOTS_TPL_FOR_COMMAND_AND_RESPONSE);
                            }
                            else if (scenarios.includes(question_1.BotScenario.NotificationBot)) {
                                // notification
                                remoteManifest.bots = remoteManifest.bots.concat(constants_1.BOTS_TPL_FOR_NOTIFICATION);
                            }
                            else {
                                // legacy bot
                                remoteManifest.bots = remoteManifest.bots.concat(constants_1.BOTS_TPL_FOR_MULTI_ENV);
                            }
                        }
                        else {
                            remoteManifest.bots = remoteManifest.bots.concat(constants_1.BOTS_TPL_FOR_MULTI_ENV);
                        }
                    }
                }
                break;
            case "MessageExtension":
                if (!remoteManifest.composeExtensions) {
                    Object.assign(remoteManifest, { composeExtensions: [] });
                }
                if (capability.snippet) {
                    remoteManifest.composeExtensions.push(capability.snippet);
                }
                else {
                    if (capability.existingApp) {
                        remoteManifest.composeExtensions = remoteManifest.composeExtensions.concat(constants_1.COMPOSE_EXTENSIONS_TPL_EXISTING_APP);
                    }
                    else {
                        remoteManifest.composeExtensions = remoteManifest.composeExtensions.concat(constants_1.COMPOSE_EXTENSIONS_TPL_FOR_MULTI_ENV);
                    }
                }
                break;
            case "WebApplicationInfo":
                if (capability.snippet) {
                    remoteManifest.webApplicationInfo = capability.snippet;
                }
                else {
                    remoteManifest.webApplicationInfo = constants_1.WEB_APPLICATION_INFO_MULTI_ENV;
                }
                break;
        }
    });
    const res = await saveManifest(projectRoot, remoteManifest, false);
    if (res.isErr()) {
        return teamsfx_api_1.err(res.error);
    }
    if (!common_1.isConfigUnifyEnabled()) {
        const localManifestRes = await loadManifest(projectRoot, true);
        if (localManifestRes.isErr()) {
            return teamsfx_api_1.err(localManifestRes.error);
        }
        const localManifest = localManifestRes.value;
        let staticTabIndex = (_d = (_c = localManifest.staticTabs) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0;
        capabilities.map((capability) => {
            switch (capability.name) {
                case "staticTab":
                    if (!localManifest.staticTabs) {
                        Object.assign(localManifest, { staticTabs: [] });
                    }
                    if (capability.existingApp) {
                        const template = common_1.deepCopy(constants_1.STATIC_TABS_TPL_EXISTING_APP[0]);
                        template.entityId = "index" + staticTabIndex;
                        localManifest.staticTabs.push(template);
                    }
                    else {
                        const template = common_1.deepCopy(constants_1.STATIC_TABS_TPL_LOCAL_DEBUG[0]);
                        template.entityId = "index" + staticTabIndex;
                        localManifest.staticTabs.push(template);
                    }
                    staticTabIndex++;
                    break;
                case "configurableTab":
                    if (!localManifest.configurableTabs) {
                        Object.assign(localManifest, { configurableTabs: [] });
                    }
                    if (capability.existingApp) {
                        localManifest.configurableTabs = localManifest.configurableTabs.concat(constants_1.CONFIGURABLE_TABS_TPL_EXISTING_APP);
                    }
                    else {
                        localManifest.configurableTabs = localManifest.configurableTabs.concat(constants_1.CONFIGURABLE_TABS_TPL_LOCAL_DEBUG);
                    }
                    break;
                case "Bot":
                    if (!localManifest.bots) {
                        Object.assign(localManifest, { bots: [] });
                    }
                    if (capability.existingApp) {
                        localManifest.bots = localManifest.bots.concat(constants_1.BOTS_TPL_EXISTING_APP);
                    }
                    else {
                        localManifest.bots = localManifest.bots.concat(constants_1.BOTS_TPL_LOCAL_DEBUG);
                    }
                    break;
                case "MessageExtension":
                    if (!localManifest.composeExtensions) {
                        Object.assign(localManifest, { composeExtensions: [] });
                    }
                    if (capability.existingApp) {
                        localManifest.composeExtensions = localManifest.composeExtensions.concat(constants_1.COMPOSE_EXTENSIONS_TPL_EXISTING_APP);
                    }
                    else {
                        localManifest.composeExtensions = localManifest.composeExtensions.concat(constants_1.COMPOSE_EXTENSIONS_TPL_LOCAL_DEBUG);
                    }
                    break;
                case "WebApplicationInfo":
                    if (!localManifest.webApplicationInfo) {
                        Object.assign(localManifest, { webApplicationInfo: [] });
                    }
                    localManifest.webApplicationInfo = constants_1.WEB_APPLICATION_INFO_LOCAL_DEBUG;
                    break;
            }
        });
        const res = await saveManifest(projectRoot, localManifest, true);
        if (res.isErr()) {
            return teamsfx_api_1.err(res.error);
        }
    }
    return teamsfx_api_1.ok(undefined);
}
exports.addCapabilities = addCapabilities;
async function updateCapability(projectRoot, capability) {
    var _a;
    const manifestRes = await loadManifest(projectRoot, false);
    if (manifestRes.isErr()) {
        return teamsfx_api_1.err(manifestRes.error);
    }
    const manifest = manifestRes.value;
    switch (capability.name) {
        case "staticTab":
            // find the corresponding static Tab with entity id
            const entityId = capability.snippet.entityId;
            const index = (_a = manifest.staticTabs) === null || _a === void 0 ? void 0 : _a.map((x) => x.entityId).indexOf(entityId);
            if (index !== undefined && index !== -1) {
                manifest.staticTabs[index] = capability.snippet;
            }
            else {
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.StaticTabNotExistError.name, errors_1.AppStudioError.StaticTabNotExistError.message(entityId)));
            }
            break;
        case "configurableTab":
            if (manifest.configurableTabs && manifest.configurableTabs.length) {
                manifest.configurableTabs[0] = capability.snippet;
            }
            else {
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.CapabilityNotExistError.name, errors_1.AppStudioError.CapabilityNotExistError.message(capability.name)));
            }
            break;
        case "Bot":
            if (manifest.bots && manifest.bots.length > 0) {
                manifest.bots[0] = capability.snippet;
            }
            else {
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.CapabilityNotExistError.name, errors_1.AppStudioError.CapabilityNotExistError.message(capability.name)));
            }
            break;
        case "MessageExtension":
            if (manifest.composeExtensions && manifest.composeExtensions.length > 0) {
                manifest.composeExtensions[0] = capability.snippet;
            }
            else {
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.CapabilityNotExistError.name, errors_1.AppStudioError.CapabilityNotExistError.message(capability.name)));
            }
            break;
        case "WebApplicationInfo":
            manifest.webApplicationInfo = capability.snippet;
            break;
    }
    const res = await saveManifest(projectRoot, manifest, false);
    if (res.isErr()) {
        return teamsfx_api_1.err(res.error);
    }
    return teamsfx_api_1.ok(undefined);
}
exports.updateCapability = updateCapability;
async function deleteCapability(projectRoot, capability) {
    var _a;
    const manifestRes = await loadManifest(projectRoot, false);
    if (manifestRes.isErr()) {
        return teamsfx_api_1.err(manifestRes.error);
    }
    const manifest = manifestRes.value;
    switch (capability.name) {
        case "staticTab":
            // find the corresponding static Tab with entity id
            const entityId = capability.snippet.entityId;
            const index = (_a = manifest.staticTabs) === null || _a === void 0 ? void 0 : _a.map((x) => x.entityId).indexOf(entityId);
            if (index !== undefined && index !== -1) {
                manifest.staticTabs.slice(index, 1);
            }
            else {
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.StaticTabNotExistError.name, errors_1.AppStudioError.StaticTabNotExistError.message(entityId)));
            }
            break;
        case "configurableTab":
            if (manifest.configurableTabs && manifest.configurableTabs.length > 0) {
                manifest.configurableTabs = [];
            }
            else {
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.CapabilityNotExistError.name, errors_1.AppStudioError.CapabilityNotExistError.message(capability.name)));
            }
            break;
        case "Bot":
            if (manifest.bots && manifest.bots.length > 0) {
                manifest.bots = [];
            }
            else {
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.CapabilityNotExistError.name, errors_1.AppStudioError.CapabilityNotExistError.message(capability.name)));
            }
            break;
        case "MessageExtension":
            if (manifest.composeExtensions && manifest.composeExtensions.length > 0) {
                manifest.composeExtensions = [];
            }
            else {
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.CapabilityNotExistError.name, errors_1.AppStudioError.CapabilityNotExistError.message(capability.name)));
            }
            break;
        case "WebApplicationInfo":
            manifest.webApplicationInfo = undefined;
            break;
    }
    const res = await saveManifest(projectRoot, manifest, false);
    if (res.isErr()) {
        return teamsfx_api_1.err(res.error);
    }
    return teamsfx_api_1.ok(undefined);
}
exports.deleteCapability = deleteCapability;
//# sourceMappingURL=manifestTemplate.js.map