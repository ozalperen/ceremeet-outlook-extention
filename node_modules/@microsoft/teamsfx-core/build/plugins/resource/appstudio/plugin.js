"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.createManifest = exports.createLocalManifest = exports.AppStudioPluginImpl = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const appStudio_1 = require("./appStudio");
const question_1 = require("../../solution/fx-solution/question");
const constants_1 = require("../../solution/fx-solution/constants");
const errors_1 = require("./errors");
const results_1 = require("./results");
const constants_2 = require("./constants");
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const fs = tslib_1.__importStar(require("fs-extra"));
const folder_1 = require("../../../folder");
const path_1 = tslib_1.__importDefault(require("path"));
const util = tslib_1.__importStar(require("util"));
const common_1 = require("../../../common");
const localSettingsConstants_1 = require("../../../common/localSettingsConstants");
const uuid_1 = require("uuid");
const isUUID_1 = tslib_1.__importDefault(require("validator/lib/isUUID"));
const mustache_1 = tslib_1.__importDefault(require("mustache"));
const utils_1 = require("./utils/utils");
const telemetry_1 = require("./utils/telemetry");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const constants_3 = require("../../../common/constants");
const manifestTemplate_1 = require("./manifestTemplate");
const environment_1 = require("../../../core/environment");
const localizeUtils_1 = require("../../../common/localizeUtils");
class AppStudioPluginImpl {
    constructor() {
        this.commonProperties = {};
    }
    async getAppDefinitionAndUpdate(ctx, isLocalDebug, manifest) {
        var _a, _b;
        let teamsAppId;
        const appDirectory = await common_1.getAppDirectory(ctx.root);
        const appStudioToken = await ((_a = ctx.appStudioToken) === null || _a === void 0 ? void 0 : _a.getAccessToken());
        if (isLocalDebug) {
            const appDefinitionAndManifest = await this.getAppDefinitionAndManifest(ctx, true);
            if (appDefinitionAndManifest.isErr()) {
                return teamsfx_api_1.err(appDefinitionAndManifest.error);
            }
            const localTeamsAppID = await this.getTeamsAppId(ctx, true);
            let createIfNotExist = false;
            if (!localTeamsAppID) {
                createIfNotExist = true;
            }
            else {
                const appStudioToken = await ((_b = ctx === null || ctx === void 0 ? void 0 : ctx.appStudioToken) === null || _b === void 0 ? void 0 : _b.getAccessToken());
                try {
                    await appStudio_1.AppStudioClient.getApp(localTeamsAppID, appStudioToken, ctx.logProvider);
                }
                catch (error) {
                    createIfNotExist = true;
                }
            }
            teamsAppId = await this.updateApp(ctx, appDefinitionAndManifest.value[0], appStudioToken, isLocalDebug, createIfNotExist, appDirectory, createIfNotExist ? undefined : localTeamsAppID, ctx.logProvider);
            return teamsAppId;
        }
        else {
            const appDefinitionRes = await this.convertToAppDefinition(ctx, manifest, true);
            if (appDefinitionRes.isErr()) {
                return teamsfx_api_1.err(appDefinitionRes.error);
            }
            teamsAppId = await this.updateApp(ctx, appDefinitionRes.value, appStudioToken, isLocalDebug, true, appDirectory, undefined, ctx.logProvider);
            return teamsAppId;
        }
    }
    async getSPFxLocalDebugAppDefinitionAndUpdate(ctx, manifest) {
        var _a;
        const appDirectory = await common_1.getAppDirectory(ctx.root);
        const appStudioToken = await ((_a = ctx.appStudioToken) === null || _a === void 0 ? void 0 : _a.getAccessToken());
        const localTeamsAppID = await this.getTeamsAppId(ctx, true);
        let create = !localTeamsAppID;
        if (localTeamsAppID) {
            try {
                await appStudio_1.AppStudioClient.getApp(localTeamsAppID, appStudioToken, ctx.logProvider);
            }
            catch (error) {
                create = true;
            }
        }
        const view = {
            config: ctx.envInfo.config,
            localSettings: {
                teamsApp: {
                    teamsAppId: localTeamsAppID,
                },
            },
        };
        mustache_1.default.escape = (value) => value;
        const manifestString = mustache_1.default.render(JSON.stringify(manifest), view);
        manifest = JSON.parse(manifestString);
        const appDefinition = await this.convertToAppDefinition(ctx, manifest, false);
        if (appDefinition.isErr()) {
            return teamsfx_api_1.err(appDefinition.error);
        }
        const teamsAppId = await this.updateApp(ctx, appDefinition.value, appStudioToken, true, create, appDirectory, create ? undefined : localTeamsAppID, ctx.logProvider);
        return teamsAppId;
    }
    async provision(ctx) {
        var _a, _b, _c, _d;
        const provisionProgress = (_a = ctx.ui) === null || _a === void 0 ? void 0 : _a.createProgressBar(localizeUtils_1.getLocalizedString("plugins.appstudio.provisionTitle"), 1);
        await (provisionProgress === null || provisionProgress === void 0 ? void 0 : provisionProgress.start());
        await (provisionProgress === null || provisionProgress === void 0 ? void 0 : provisionProgress.next(localizeUtils_1.getLocalizedString("plugins.appstudio.provisionProgress", ctx.projectSettings.appName)));
        let remoteTeamsAppId = await this.getTeamsAppId(ctx, false);
        let create = false;
        if (!remoteTeamsAppId) {
            create = true;
        }
        else {
            const appStudioToken = await ((_b = ctx === null || ctx === void 0 ? void 0 : ctx.appStudioToken) === null || _b === void 0 ? void 0 : _b.getAccessToken());
            try {
                await appStudio_1.AppStudioClient.getApp(remoteTeamsAppId, appStudioToken, ctx.logProvider);
            }
            catch (error) {
                create = true;
            }
        }
        if (create) {
            const result = await this.createApp(ctx, false);
            if (result.isErr()) {
                await (provisionProgress === null || provisionProgress === void 0 ? void 0 : provisionProgress.end(false));
                return teamsfx_api_1.err(result.error);
            }
            remoteTeamsAppId = result.value.teamsAppId;
            (_c = ctx.logProvider) === null || _c === void 0 ? void 0 : _c.info(localizeUtils_1.getLocalizedString("plugins.appstudio.teamsAppCreatedNotice", remoteTeamsAppId));
        }
        (_d = ctx.envInfo.state.get(constants_1.PluginNames.APPST)) === null || _d === void 0 ? void 0 : _d.set(constants_2.Constants.TEAMS_APP_ID, remoteTeamsAppId);
        await (provisionProgress === null || provisionProgress === void 0 ? void 0 : provisionProgress.end(true));
        return teamsfx_api_1.ok(remoteTeamsAppId);
    }
    async postProvision(ctx) {
        var _a, _b, _c;
        const postProvisionProgress = (_a = ctx.ui) === null || _a === void 0 ? void 0 : _a.createProgressBar(localizeUtils_1.getLocalizedString("plugins.appstudio.provisionTitle"), 1);
        await (postProvisionProgress === null || postProvisionProgress === void 0 ? void 0 : postProvisionProgress.start(localizeUtils_1.getLocalizedString("plugins.appstudio.postProvisionProgress", ctx.projectSettings.appName)));
        await (postProvisionProgress === null || postProvisionProgress === void 0 ? void 0 : postProvisionProgress.next());
        const remoteTeamsAppId = await this.getTeamsAppId(ctx, false);
        let manifestString;
        const manifestResult = await manifestTemplate_1.loadManifest(ctx.root, false);
        if (manifestResult.isErr()) {
            await (postProvisionProgress === null || postProvisionProgress === void 0 ? void 0 : postProvisionProgress.end(false));
            return teamsfx_api_1.err(manifestResult.error);
        }
        else {
            manifestString = JSON.stringify(manifestResult.value);
        }
        let appDefinition;
        if (common_1.isSPFxProject(ctx.projectSettings)) {
            manifestString = await this.getSPFxManifest(ctx, false);
            const appDefinitionRes = await this.convertToAppDefinition(ctx, JSON.parse(manifestString), false);
            if (appDefinitionRes.isErr()) {
                await (postProvisionProgress === null || postProvisionProgress === void 0 ? void 0 : postProvisionProgress.end(false));
                return teamsfx_api_1.err(appDefinitionRes.error);
            }
            appDefinition = appDefinitionRes.value;
        }
        else {
            const remoteManifest = await this.getAppDefinitionAndManifest(ctx, false);
            if (remoteManifest.isErr()) {
                await (postProvisionProgress === null || postProvisionProgress === void 0 ? void 0 : postProvisionProgress.end(false));
                return teamsfx_api_1.err(remoteManifest.error);
            }
            [appDefinition] = remoteManifest.value;
        }
        const appDirectory = await common_1.getAppDirectory(ctx.root);
        const appStudioToken = await ((_b = ctx === null || ctx === void 0 ? void 0 : ctx.appStudioToken) === null || _b === void 0 ? void 0 : _b.getAccessToken());
        const result = await this.updateApp(ctx, appDefinition, appStudioToken, false, false, appDirectory, remoteTeamsAppId, ctx.logProvider);
        if (result.isErr()) {
            await (postProvisionProgress === null || postProvisionProgress === void 0 ? void 0 : postProvisionProgress.end(false));
            return teamsfx_api_1.err(result.error);
        }
        (_c = ctx.logProvider) === null || _c === void 0 ? void 0 : _c.info(localizeUtils_1.getLocalizedString("plugins.appstudio.teamsAppUpdatedLog", remoteTeamsAppId));
        await (postProvisionProgress === null || postProvisionProgress === void 0 ? void 0 : postProvisionProgress.end(true));
        return teamsfx_api_1.ok(remoteTeamsAppId);
    }
    async validateManifest(ctx, isLocalDebug) {
        var _a;
        let manifestString = undefined;
        if (common_1.isSPFxProject(ctx.projectSettings)) {
            manifestString = await this.getSPFxManifest(ctx, isLocalDebug);
            const manifest = JSON.parse(manifestString);
            if (!isUUID_1.default(manifest.id)) {
                manifest.id = uuid_1.v4();
            }
            manifestString = JSON.stringify(manifest, null, 4);
        }
        else {
            const appDefinitionAndManifest = await this.getAppDefinitionAndManifest(ctx, isLocalDebug);
            if (appDefinitionAndManifest.isErr()) {
                (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.error(localizeUtils_1.getLocalizedString("plugins.appstudio.validationFailedNotice"));
                return teamsfx_api_1.err(appDefinitionAndManifest.error);
            }
            else {
                manifestString = JSON.stringify(appDefinitionAndManifest.value[1]);
            }
        }
        const manifest = JSON.parse(manifestString);
        let errors;
        const res = await this.validateManifestAgainstSchema(manifest);
        if (res.isOk()) {
            errors = res.value;
        }
        else {
            return teamsfx_api_1.err(res.error);
        }
        const appDirectory = await common_1.getAppDirectory(ctx.root);
        if (manifest.icons.outline) {
            if (manifest.icons.outline.startsWith("https://") ||
                manifest.icons.outline.startsWith("http://")) {
                errors.push(localizeUtils_1.getLocalizedString("plugins.appstudio.relativePathTip", "icons.outline"));
            }
            else {
                const outlineFile = path_1.default.join(appDirectory, manifest.icons.outline);
                if (!(await fs.pathExists(outlineFile))) {
                    errors.push(localizeUtils_1.getLocalizedString("error.appstudio.fileNotFoundError", outlineFile));
                }
            }
        }
        if (manifest.icons.color) {
            if (manifest.icons.color.startsWith("https://") ||
                manifest.icons.color.startsWith("http://")) {
                errors.push(localizeUtils_1.getLocalizedString("plugins.appstudio.relativePathTip", "icons.color"));
            }
            else {
                const colorFile = path_1.default.join(appDirectory, manifest.icons.color);
                if (!(await fs.pathExists(colorFile))) {
                    errors.push(localizeUtils_1.getLocalizedString("error.appstudio.fileNotFoundError", colorFile));
                }
            }
        }
        return teamsfx_api_1.ok(errors);
    }
    async deploy(ctx) {
        return this.updateManifest(ctx, false);
    }
    async updateManifest(ctx, isLocalDebug) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const teamsAppId = await this.getTeamsAppId(ctx, isLocalDebug);
        let manifest;
        let manifestString;
        const manifestResult = await manifestTemplate_1.loadManifest(ctx.root, isLocalDebug);
        if (manifestResult.isErr()) {
            return teamsfx_api_1.err(manifestResult.error);
        }
        else {
            manifestString = JSON.stringify(manifestResult.value);
        }
        let appDefinition;
        if (common_1.isSPFxProject(ctx.projectSettings)) {
            manifestString = await this.getSPFxManifest(ctx, isLocalDebug);
            manifest = JSON.parse(manifestString);
            const appDefinitionRes = await this.convertToAppDefinition(ctx, manifest, false);
            if (appDefinitionRes.isErr()) {
                return teamsfx_api_1.err(appDefinitionRes.error);
            }
            appDefinition = appDefinitionRes.value;
        }
        else {
            const appManifest = await this.getAppDefinitionAndManifest(ctx, isLocalDebug);
            if (appManifest.isErr()) {
                (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.error(localizeUtils_1.getLocalizedString("error.appstudio.updateManifestFailed"));
                const isProvisionSucceeded = !!((_b = ctx.envInfo.state
                    .get("solution")) === null || _b === void 0 ? void 0 : _b.get(constants_1.SOLUTION_PROVISION_SUCCEEDED));
                if (appManifest.error.name === errors_1.AppStudioError.GetRemoteConfigFailedError.name &&
                    !isProvisionSucceeded) {
                    return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.GetRemoteConfigFailedError.name, errors_1.AppStudioError.GetRemoteConfigFailedError.message(localizeUtils_1.getLocalizedString("error.appstudio.updateManifestFailed"), isProvisionSucceeded), constants_3.HelpLinks.WhyNeedProvision));
                }
                else {
                    return teamsfx_api_1.err(appManifest.error);
                }
            }
            [appDefinition] = appManifest.value;
            manifest = appManifest.value[1];
        }
        const manifestFileName = `${ctx.root}/${teamsfx_api_1.BuildFolderName}/${teamsfx_api_1.AppPackageFolderName}/manifest.` +
            (isLocalDebug ? "local" : ctx.envInfo.envName) +
            `.json`;
        if (!(await fs.pathExists(manifestFileName))) {
            const isProvisionSucceeded = !!((_c = ctx.envInfo.state
                .get("solution")) === null || _c === void 0 ? void 0 : _c.get(constants_1.SOLUTION_PROVISION_SUCCEEDED));
            if (!isProvisionSucceeded) {
                const msgs = errors_1.AppStudioError.FileNotFoundError.message(manifestFileName);
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, [
                    msgs[0] + localizeUtils_1.getDefaultString("plugins.appstudio.provisionTip"),
                    msgs[1] + localizeUtils_1.getLocalizedString("plugins.appstudio.provisionTip"),
                ], constants_3.HelpLinks.WhyNeedProvision));
            }
            await this.buildTeamsAppPackage(ctx, isLocalDebug);
        }
        const existingManifest = await fs.readJSON(manifestFileName);
        delete manifest.id;
        delete existingManifest.id;
        if (!lodash_1.default.isEqual(manifest, existingManifest)) {
            const res = await ((_d = ctx.ui) === null || _d === void 0 ? void 0 : _d.showMessage("warn", localizeUtils_1.getLocalizedString("plugins.appstudio.updateManifestTip"), true, "Preview only", "Preview and update"));
            const error = results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.UpdateManifestCancelError.name, errors_1.AppStudioError.UpdateManifestCancelError.message(manifest.name.short));
            if ((res === null || res === void 0 ? void 0 : res.isOk()) && res.value === "Preview only") {
                this.buildTeamsAppPackage(ctx, isLocalDebug);
                return teamsfx_api_1.err(error);
            }
            else if ((res === null || res === void 0 ? void 0 : res.isOk()) && res.value === "Preview and update") {
                this.buildTeamsAppPackage(ctx, isLocalDebug);
            }
            else {
                return teamsfx_api_1.err(error);
            }
        }
        const appStudioToken = await ((_e = ctx === null || ctx === void 0 ? void 0 : ctx.appStudioToken) === null || _e === void 0 ? void 0 : _e.getAccessToken());
        try {
            const localUpdateTime = isLocalDebug
                ? undefined
                : (_f = ctx.envInfo.state.get(constants_1.PluginNames.APPST)) === null || _f === void 0 ? void 0 : _f.get(constants_2.Constants.TEAMS_APP_UPDATED_AT);
            if (localUpdateTime) {
                const app = await appStudio_1.AppStudioClient.getApp(teamsAppId, appStudioToken, ctx.logProvider);
                const devPortalUpdateTime = (_h = (_g = new Date(app.updatedAt)) === null || _g === void 0 ? void 0 : _g.getTime()) !== null && _h !== void 0 ? _h : -1;
                if (localUpdateTime < devPortalUpdateTime) {
                    const res = await ((_j = ctx.ui) === null || _j === void 0 ? void 0 : _j.showMessage("warn", localizeUtils_1.getLocalizedString("plugins.appstudio.updateOverwriteTip"), true, "Overwrite and update"));
                    if (!((res === null || res === void 0 ? void 0 : res.isOk()) && res.value === "Overwrite and update")) {
                        const error = results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.UpdateManifestCancelError.name, errors_1.AppStudioError.UpdateManifestCancelError.message(manifest.name.short));
                        return teamsfx_api_1.err(error);
                    }
                }
            }
            const appDirectory = await common_1.getAppDirectory(ctx.root);
            const result = await this.updateApp(ctx, appDefinition, appStudioToken, isLocalDebug, false, appDirectory, teamsAppId, ctx.logProvider);
            if (result.isErr()) {
                return teamsfx_api_1.err(result.error);
            }
            (_k = ctx.logProvider) === null || _k === void 0 ? void 0 : _k.info(localizeUtils_1.getLocalizedString("plugins.appstudio.teamsAppUpdatedLog", teamsAppId));
            (_l = ctx.ui) === null || _l === void 0 ? void 0 : _l.showMessage("info", localizeUtils_1.getLocalizedString("plugins.appstudio.teamsAppUpdatedNotice"), false, constants_2.Constants.VIEW_DEVELOPER_PORTAL).then((res) => {
                var _a;
                if ((res === null || res === void 0 ? void 0 : res.isOk()) && res.value === constants_2.Constants.VIEW_DEVELOPER_PORTAL) {
                    (_a = ctx.ui) === null || _a === void 0 ? void 0 : _a.openUrl(util.format(constants_2.Constants.DEVELOPER_PORTAL_APP_PACKAGE_URL, result.value));
                }
            });
            return teamsfx_api_1.ok(teamsAppId);
        }
        catch (error) {
            if (error.message && error.message.includes("404")) {
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.UpdateManifestWithInvalidAppError.name, errors_1.AppStudioError.UpdateManifestWithInvalidAppError.message(teamsAppId)));
            }
            else {
                return teamsfx_api_1.err(error);
            }
        }
    }
    async scaffold(ctx) {
        var _a, _b, _c;
        let manifest;
        const templatesFolder = folder_1.getTemplatesFolder();
        // cannot use getAppDirectory before creating the manifest file
        const appDir = `${ctx.root}/${constants_2.APP_PACKAGE_FOLDER_FOR_MULTI_ENV}`;
        if (common_1.isSPFxProject(ctx.projectSettings)) {
            const templateManifestFolder = path_1.default.join(templatesFolder, "plugins", "resource", "spfx");
            const manifestFile = path_1.default.resolve(templateManifestFolder, "./solution/manifest_multi_env.json");
            const manifestString = (await fs.readFile(manifestFile)).toString();
            manifest = JSON.parse(manifestString);
            if (!common_1.isConfigUnifyEnabled()) {
                const localManifest = await createLocalManifest(ctx.projectSettings.appName, false, false, false, true);
                await fs.writeFile(`${appDir}/${constants_2.MANIFEST_LOCAL}`, JSON.stringify(localManifest, null, 4));
            }
        }
        else {
            const solutionSettings = (_a = ctx.projectSettings) === null || _a === void 0 ? void 0 : _a.solutionSettings;
            const hasFrontend = solutionSettings.capabilities.includes(question_1.TabOptionItem.id);
            const hasBot = solutionSettings.capabilities.includes(question_1.BotOptionItem.id);
            const scenarios = (_b = ctx.answers) === null || _b === void 0 ? void 0 : _b[question_1.AzureSolutionQuestionNames.Scenarios];
            const hasCommandAndResponseBot = (scenarios === null || scenarios === void 0 ? void 0 : scenarios.includes) && scenarios.includes(question_1.BotScenario.CommandAndResponseBot);
            const hasNotificationBot = (scenarios === null || scenarios === void 0 ? void 0 : scenarios.includes) && scenarios.includes(question_1.BotScenario.NotificationBot);
            const hasMessageExtension = solutionSettings.capabilities.includes(question_1.MessageExtensionItem.id);
            const hasAad = common_1.isAADEnabled(solutionSettings);
            const isM365 = (_c = ctx.projectSettings) === null || _c === void 0 ? void 0 : _c.isM365;
            manifest = await createManifest(ctx.projectSettings.appName, hasFrontend, hasBot, hasNotificationBot, hasCommandAndResponseBot, hasMessageExtension, false, hasAad, isM365);
            if (!common_1.isConfigUnifyEnabled()) {
                const localDebugManifest = await createLocalManifest(ctx.projectSettings.appName, hasFrontend, hasBot, hasMessageExtension, false, hasAad, isM365);
                await fs.writeFile(`${appDir}/${constants_2.MANIFEST_LOCAL}`, JSON.stringify(localDebugManifest, null, 4));
            }
        }
        await fs.ensureDir(appDir);
        const manifestTemplatePath = await manifestTemplate_1.getManifestTemplatePath(ctx.root);
        await fs.writeFile(manifestTemplatePath, JSON.stringify(manifest, null, 4));
        const defaultColorPath = path_1.default.join(templatesFolder, constants_2.COLOR_TEMPLATE);
        const defaultOutlinePath = path_1.default.join(templatesFolder, constants_2.OUTLINE_TEMPLATE);
        const resourcesDir = path_1.default.join(appDir, constants_2.MANIFEST_RESOURCES);
        await fs.ensureDir(resourcesDir);
        await fs.copy(defaultColorPath, `${resourcesDir}/${constants_2.DEFAULT_COLOR_PNG_FILENAME}`);
        await fs.copy(defaultOutlinePath, `${resourcesDir}/${constants_2.DEFAULT_OUTLINE_PNG_FILENAME}`);
        return undefined;
    }
    async buildTeamsAppPackage(ctx, isLocalDebug) {
        var _a, _b, _c;
        // Validate manifest
        const validationResult = await this.validateManifest(ctx, isLocalDebug);
        if (validationResult.isOk() && validationResult.value.length > 0) {
            const errMessage = errors_1.AppStudioError.ValidationFailedError.message(validationResult.value);
            const validationFailed = results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, errMessage);
            throw validationFailed;
        }
        let manifestString = undefined;
        if (!((_a = ctx.envInfo) === null || _a === void 0 ? void 0 : _a.envName)) {
            throw results_1.AppStudioResultFactory.SystemError("InvalidInputError", [
                localizeUtils_1.getDefaultString("error.appstudio.noEnvInfo"),
                localizeUtils_1.getLocalizedString("error.appstudio.noEnvInfo"),
            ]);
        }
        const appDirectory = await common_1.getAppDirectory(ctx.root);
        let zipFileName;
        if (isLocalDebug) {
            zipFileName = path_1.default.join(ctx.root, teamsfx_api_1.BuildFolderName, teamsfx_api_1.AppPackageFolderName, "appPackage.local.zip");
        }
        else {
            zipFileName = path_1.default.join(ctx.root, teamsfx_api_1.BuildFolderName, teamsfx_api_1.AppPackageFolderName, `appPackage.${ctx.envInfo.envName}.zip`);
        }
        if (common_1.isSPFxProject(ctx.projectSettings)) {
            manifestString = await this.getSPFxManifest(ctx, isLocalDebug);
            const manifest = JSON.parse(manifestString);
            if (!isUUID_1.default(manifest.id)) {
                manifest.id = uuid_1.v4();
            }
            manifestString = JSON.stringify(manifest, null, 4);
        }
        else {
            const manifest = await this.getAppDefinitionAndManifest(ctx, isLocalDebug);
            if (manifest.isOk()) {
                manifestString = JSON.stringify(manifest.value[1], null, 4);
            }
            else {
                (_b = ctx.logProvider) === null || _b === void 0 ? void 0 : _b.error(localizeUtils_1.getLocalizedString("plugins.appstudio.buildFailedNotice"));
                const isProvisionSucceeded = !!((_c = ctx.envInfo.state
                    .get("solution")) === null || _c === void 0 ? void 0 : _c.get(constants_1.SOLUTION_PROVISION_SUCCEEDED));
                if (manifest.error.name === errors_1.AppStudioError.GetRemoteConfigFailedError.name &&
                    !isProvisionSucceeded) {
                    throw results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.GetRemoteConfigFailedError.name, errors_1.AppStudioError.GetRemoteConfigFailedError.message(localizeUtils_1.getLocalizedString("plugins.appstudio.buildFailedNotice"), isProvisionSucceeded), constants_3.HelpLinks.WhyNeedProvision);
                }
                else {
                    throw manifest.error;
                }
            }
        }
        const status = await fs.lstat(appDirectory);
        if (!status.isDirectory()) {
            throw results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.NotADirectoryError.name, errors_1.AppStudioError.NotADirectoryError.message(appDirectory));
        }
        const zip = new adm_zip_1.default();
        zip.addFile(constants_2.Constants.MANIFEST_FILE, Buffer.from(manifestString));
        const manifest = JSON.parse(manifestString);
        // color icon
        if (manifest.icons.color && !manifest.icons.color.startsWith("https://")) {
            const colorFile = `${appDirectory}/${manifest.icons.color}`;
            const fileExists = await fs.pathExists(colorFile);
            if (!fileExists) {
                throw results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(colorFile));
            }
            const dir = path_1.default.dirname(manifest.icons.color);
            zip.addLocalFile(colorFile, dir === "." ? "" : dir);
        }
        // outline icon
        if (manifest.icons.outline && !manifest.icons.outline.startsWith("https://")) {
            const outlineFile = `${appDirectory}/${manifest.icons.outline}`;
            const fileExists = await fs.pathExists(outlineFile);
            if (!fileExists) {
                throw results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(outlineFile));
            }
            const dir = path_1.default.dirname(manifest.icons.outline);
            zip.addLocalFile(outlineFile, dir === "." ? "" : dir);
        }
        await fs.ensureDir(path_1.default.dirname(zipFileName));
        const manifestFileName = `${ctx.root}/${teamsfx_api_1.BuildFolderName}/${teamsfx_api_1.AppPackageFolderName}/manifest.` +
            (isLocalDebug ? "local" : ctx.envInfo.envName) +
            `.json`;
        if (await fs.pathExists(manifestFileName)) {
            await fs.chmod(manifestFileName, 0o777);
        }
        await fs.writeFile(manifestFileName, manifestString);
        await fs.chmod(manifestFileName, 0o444);
        // localization file
        if (manifest.localizationInfo &&
            manifest.localizationInfo.additionalLanguages &&
            manifest.localizationInfo.additionalLanguages.length > 0) {
            await Promise.all(manifest.localizationInfo.additionalLanguages.map(async function (language) {
                const file = language.file;
                const fileName = `${appDirectory}/${file}`;
                if (!(await fs.pathExists(fileName))) {
                    throw results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(fileName));
                }
                const dir = path_1.default.dirname(file);
                zip.addLocalFile(fileName, dir === "." ? "" : dir);
            }));
        }
        zip.writeZip(zipFileName);
        if (common_1.isSPFxProject(ctx.projectSettings)) {
            const spfxTeamsPath = `${ctx.root}/SPFx/teams`;
            await fs.copyFile(zipFileName, path_1.default.join(spfxTeamsPath, "TeamsSPFxApp.zip"));
            for (const file of await fs.readdir(`${ctx.root}/SPFx/teams/`)) {
                if (file.endsWith("color.png") &&
                    manifest.icons.color &&
                    !manifest.icons.color.startsWith("https://")) {
                    const colorFile = `${appDirectory}/${manifest.icons.color}`;
                    const color = await fs.readFile(colorFile);
                    await fs.writeFile(path_1.default.join(spfxTeamsPath, file), color);
                }
                else if (file.endsWith("outline.png") &&
                    manifest.icons.outline &&
                    !manifest.icons.outline.startsWith("https://")) {
                    const outlineFile = `${appDirectory}/${manifest.icons.outline}`;
                    const outline = await fs.readFile(outlineFile);
                    await fs.writeFile(path_1.default.join(spfxTeamsPath, file), outline);
                }
            }
        }
        if (appDirectory === `${ctx.root}/.${teamsfx_api_1.ConfigFolderName}`) {
            await fs.ensureDir(path_1.default.join(ctx.root, `${teamsfx_api_1.AppPackageFolderName}`));
            const formerZipFileName = `${appDirectory}/appPackage.zip`;
            if (await fs.pathExists(formerZipFileName)) {
                await fs.remove(formerZipFileName);
            }
            await fs.move(`${appDirectory}/${manifest.icons.color}`, `${ctx.root}/${constants_2.APP_PACKAGE_FOLDER_FOR_MULTI_ENV}/${constants_2.MANIFEST_RESOURCES}/${manifest.icons.color}`);
            await fs.move(`${appDirectory}/${manifest.icons.outline}`, `${ctx.root}/${constants_2.APP_PACKAGE_FOLDER_FOR_MULTI_ENV}/${constants_2.MANIFEST_RESOURCES}/${manifest.icons.outline}`);
            await fs.move(`${appDirectory}/${constants_2.REMOTE_MANIFEST}`, `${ctx.root}/${constants_2.APP_PACKAGE_FOLDER_FOR_MULTI_ENV}/${constants_2.MANIFEST_TEMPLATE}`);
        }
        return zipFileName;
    }
    async publish(ctx) {
        var _a, _b, _c;
        let manifest;
        const appDirectory = await common_1.getAppDirectory(ctx.root);
        if (common_1.isSPFxProject(ctx.projectSettings)) {
            const manifestString = await this.getSPFxManifest(ctx, false);
            manifest = JSON.parse(manifestString);
        }
        else {
            const fillinRes = await this.getAppDefinitionAndManifest(ctx, false);
            if (fillinRes.isOk()) {
                manifest = fillinRes.value[1];
            }
            else {
                throw fillinRes.error;
            }
        }
        if (!manifest) {
            throw results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.ManifestLoadFailedError.name, errors_1.AppStudioError.ManifestLoadFailedError.message(""));
        }
        // manifest.id === externalID
        const appStudioToken = await ((_a = ctx === null || ctx === void 0 ? void 0 : ctx.appStudioToken) === null || _a === void 0 ? void 0 : _a.getAccessToken());
        const existApp = await appStudio_1.AppStudioClient.getAppByTeamsAppId(manifest.id, appStudioToken);
        if (existApp) {
            let executePublishUpdate = false;
            let description = localizeUtils_1.getLocalizedString("plugins.appstudio.updatePublishedAppNotice", existApp.displayName, existApp.publishingState);
            if (existApp.lastModifiedDateTime) {
                description =
                    description +
                        localizeUtils_1.getLocalizedString("plugins.appstudio.lastModifiedTip", (_b = existApp.lastModifiedDateTime) === null || _b === void 0 ? void 0 : _b.toLocaleString());
            }
            description = description + localizeUtils_1.getLocalizedString("plugins.appstudio.updatePublihsedAppConfirm");
            const res = await ((_c = ctx.ui) === null || _c === void 0 ? void 0 : _c.showMessage("warn", description, true, "Confirm"));
            if ((res === null || res === void 0 ? void 0 : res.isOk()) && res.value === "Confirm")
                executePublishUpdate = true;
            if (executePublishUpdate) {
                const appId = await this.beforePublish(ctx, appDirectory, JSON.stringify(manifest), true);
                return { id: appId, name: manifest.name.short, update: true };
            }
            else {
                throw results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.TeamsAppPublishCancelError.name, errors_1.AppStudioError.TeamsAppPublishCancelError.message(manifest.name.short));
            }
        }
        else {
            const appId = await this.beforePublish(ctx, appDirectory, JSON.stringify(manifest), false);
            return { id: appId, name: manifest.name.short, update: false };
        }
    }
    async postLocalDebug(ctx) {
        var _a, _b;
        let teamsAppId;
        const manifest = await manifestTemplate_1.loadManifest(ctx.root, true);
        if (manifest.isErr()) {
            return teamsfx_api_1.err(manifest.error);
        }
        if (common_1.isSPFxProject(ctx.projectSettings)) {
            teamsAppId = await this.getSPFxLocalDebugAppDefinitionAndUpdate(ctx, manifest.value);
        }
        else {
            teamsAppId = await this.getAppDefinitionAndUpdate(ctx, true, manifest.value);
        }
        if (teamsAppId.isErr()) {
            return teamsAppId;
        }
        if (common_1.isConfigUnifyEnabled()) {
            ctx.envInfo.state
                .get(constants_3.ResourcePlugins.AppStudio)
                .set(constants_2.Constants.TEAMS_APP_ID, teamsAppId.value);
        }
        else {
            (_b = (_a = ctx.localSettings) === null || _a === void 0 ? void 0 : _a.teamsApp) === null || _b === void 0 ? void 0 : _b.set(constants_2.Constants.TEAMS_APP_ID, teamsAppId.value);
        }
        return teamsfx_api_1.ok(teamsAppId.value);
    }
    async checkPermission(ctx, userInfo) {
        var _a;
        const appStudioToken = await ((_a = ctx === null || ctx === void 0 ? void 0 : ctx.appStudioToken) === null || _a === void 0 ? void 0 : _a.getAccessToken());
        const teamsAppId = await this.getTeamsAppId(ctx, false);
        if (!teamsAppId) {
            throw new Error(constants_2.ErrorMessages.GetConfigError(constants_2.Constants.TEAMS_APP_ID, constants_1.PluginNames.APPST));
        }
        const teamsAppRoles = await appStudio_1.AppStudioClient.checkPermission(teamsAppId, appStudioToken, userInfo.aadId);
        const result = [
            {
                name: constants_2.Constants.PERMISSIONS.name,
                roles: [teamsAppRoles],
                type: constants_2.Constants.PERMISSIONS.type,
                resourceId: teamsAppId,
            },
        ];
        return result;
    }
    async listCollaborator(ctx) {
        var _a;
        const appStudioToken = await ((_a = ctx === null || ctx === void 0 ? void 0 : ctx.appStudioToken) === null || _a === void 0 ? void 0 : _a.getAccessToken());
        const teamsAppId = await this.getTeamsAppId(ctx, false);
        if (!teamsAppId) {
            throw new Error(constants_2.ErrorMessages.GetConfigError(constants_2.Constants.TEAMS_APP_ID, constants_1.PluginNames.APPST));
        }
        let userLists;
        try {
            userLists = await appStudio_1.AppStudioClient.getUserList(teamsAppId, appStudioToken);
            if (!userLists) {
                return [];
            }
        }
        catch (error) {
            if (error.name === 404) {
                error.message = constants_2.ErrorMessages.TeamsAppNotFound(teamsAppId);
            }
            throw error;
        }
        const teamsAppAdmin = userLists
            .filter((userList) => {
            return userList.isAdministrator;
        })
            .map((userList) => {
            return {
                userObjectId: userList.aadId,
                displayName: userList.displayName,
                userPrincipalName: userList.userPrincipalName,
                resourceId: teamsAppId,
            };
        });
        return teamsAppAdmin;
    }
    async grantPermission(ctx, userInfo) {
        var _a;
        const appStudioToken = await ((_a = ctx === null || ctx === void 0 ? void 0 : ctx.appStudioToken) === null || _a === void 0 ? void 0 : _a.getAccessToken());
        const teamsAppId = await this.getTeamsAppId(ctx, false);
        if (!teamsAppId) {
            const msgs = errors_1.AppStudioError.GrantPermissionFailedError.message(constants_2.ErrorMessages.GetConfigError(constants_2.Constants.TEAMS_APP_ID, constants_1.PluginNames.APPST));
            throw new teamsfx_api_1.UserError(constants_1.PluginNames.APPST, "GetConfigError", msgs[0], msgs[1]);
        }
        try {
            await appStudio_1.AppStudioClient.grantPermission(teamsAppId, appStudioToken, userInfo);
        }
        catch (error) {
            const msgs = errors_1.AppStudioError.GrantPermissionFailedError.message(error === null || error === void 0 ? void 0 : error.message, teamsAppId);
            throw new teamsfx_api_1.UserError(constants_1.PluginNames.APPST, "GrantPermissionFailedError", msgs[0], msgs[1]);
        }
        const result = [
            {
                name: constants_2.Constants.PERMISSIONS.name,
                roles: [constants_2.Constants.PERMISSIONS.admin],
                type: constants_2.Constants.PERMISSIONS.type,
                resourceId: teamsAppId,
            },
        ];
        return result;
    }
    async beforePublish(ctx, appDirectory, manifestString, update) {
        var _a, _b, _c, _d;
        const manifest = JSON.parse(manifestString);
        const publishProgress = (_a = ctx.ui) === null || _a === void 0 ? void 0 : _a.createProgressBar(`Publishing ${manifest.name.short}`, 3);
        try {
            // Validate manifest
            await (publishProgress === null || publishProgress === void 0 ? void 0 : publishProgress.start(localizeUtils_1.getLocalizedString("plugins.appstudio.validateProgressStart")));
            const validationResult = await this.validateManifestAgainstSchema(manifest);
            if (validationResult.isErr()) {
                throw validationResult.error;
            }
            else if (validationResult.value.length > 0) {
                throw results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, errors_1.AppStudioError.ValidationFailedError.message(validationResult.value));
            }
            // Update App in App Studio
            const remoteTeamsAppId = await this.getTeamsAppId(ctx, false);
            await (publishProgress === null || publishProgress === void 0 ? void 0 : publishProgress.next(localizeUtils_1.getLocalizedString("plugins.appstudio.publishProgressUpdate", remoteTeamsAppId)));
            const appDefinitionRes = await this.convertToAppDefinition(ctx, manifest, true);
            if (appDefinitionRes.isErr()) {
                throw appDefinitionRes.error;
            }
            let appStudioToken = await ((_b = ctx === null || ctx === void 0 ? void 0 : ctx.appStudioToken) === null || _b === void 0 ? void 0 : _b.getAccessToken());
            const colorIconContent = manifest.icons.color
                ? (await fs.readFile(`${appDirectory}/${manifest.icons.color}`)).toString("base64")
                : undefined;
            const outlineIconContent = manifest.icons.outline
                ? (await fs.readFile(`${appDirectory}/${manifest.icons.outline}`)).toString("base64")
                : undefined;
            try {
                const app = await appStudio_1.AppStudioClient.updateApp(remoteTeamsAppId, appDefinitionRes.value, appStudioToken, undefined, colorIconContent, outlineIconContent);
                if (app.updatedAt) {
                    (_c = ctx.envInfo.state
                        .get(constants_1.PluginNames.APPST)) === null || _c === void 0 ? void 0 : _c.set(constants_2.Constants.TEAMS_APP_UPDATED_AT, new Date(app.updatedAt).getTime());
                }
            }
            catch (e) {
                if (e.name === 404) {
                    throw results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.TeamsAppNotFoundError.name, errors_1.AppStudioError.TeamsAppNotFoundError.message(remoteTeamsAppId));
                }
            }
            // Build Teams App package
            // Platforms will be checked in buildTeamsAppPackage(ctx)
            await (publishProgress === null || publishProgress === void 0 ? void 0 : publishProgress.next(localizeUtils_1.getLocalizedString("plugins.appstudio.publishProgressBuild", appDirectory)));
            const appPackage = await this.buildTeamsAppPackage(ctx, false);
            const appContent = await fs.readFile(appPackage);
            appStudioToken = await ((_d = ctx.appStudioToken) === null || _d === void 0 ? void 0 : _d.getAccessToken());
            await (publishProgress === null || publishProgress === void 0 ? void 0 : publishProgress.next(localizeUtils_1.getLocalizedString("plugins.appstudio.publishProgressPublish", manifest.name.short)));
            if (update) {
                // Update existing app in App Catalog
                return await appStudio_1.AppStudioClient.publishTeamsAppUpdate(manifest.id, appContent, appStudioToken);
            }
            else {
                // Publish Teams App
                return await appStudio_1.AppStudioClient.publishTeamsApp(manifest.id, appContent, appStudioToken);
            }
        }
        finally {
            await (publishProgress === null || publishProgress === void 0 ? void 0 : publishProgress.end(true));
        }
    }
    async getConfigForCreatingManifest(ctx, localDebug) {
        const tabEndpoint = this.getTabEndpoint(ctx, localDebug);
        const tabDomain = this.getTabDomain(ctx, localDebug);
        const tabIndexPath = this.getTabIndexPath(ctx, localDebug);
        const aadId = this.getAadClientId(ctx, localDebug);
        const botId = this.getBotId(ctx, localDebug);
        const botDomain = this.getBotDomain(ctx, localDebug);
        const teamsAppId = await this.getTeamsAppId(ctx, localDebug);
        // This config value is set by aadPlugin.setApplicationInContext. so aadPlugin.setApplicationInContext needs to run first.
        const webApplicationInfoResource = this.getApplicationIdUris(ctx, localDebug);
        return {
            tabEndpoint,
            tabDomain,
            tabIndexPath,
            aadId,
            botDomain,
            botId,
            webApplicationInfoResource,
            teamsAppId,
        };
    }
    getTabEndpoint(ctx, isLocalDebug) {
        var _a, _b, _c;
        const tabEndpoint = isLocalDebug && !common_1.isConfigUnifyEnabled()
            ? (_b = (_a = ctx.localSettings) === null || _a === void 0 ? void 0 : _a.frontend) === null || _b === void 0 ? void 0 : _b.get(localSettingsConstants_1.LocalSettingsFrontendKeys.TabEndpoint)
            : (_c = ctx.envInfo.state.get(constants_1.PluginNames.FE)) === null || _c === void 0 ? void 0 : _c.get(constants_2.FRONTEND_ENDPOINT);
        return tabEndpoint;
    }
    getTabDomain(ctx, isLocalDebug) {
        var _a, _b, _c;
        const tabDomain = isLocalDebug && !common_1.isConfigUnifyEnabled()
            ? (_b = (_a = ctx.localSettings) === null || _a === void 0 ? void 0 : _a.frontend) === null || _b === void 0 ? void 0 : _b.get(localSettingsConstants_1.LocalSettingsFrontendKeys.TabDomain)
            : (_c = ctx.envInfo.state.get(constants_1.PluginNames.FE)) === null || _c === void 0 ? void 0 : _c.get(constants_2.FRONTEND_DOMAIN);
        return tabDomain;
    }
    getTabIndexPath(ctx, isLocalDebug) {
        var _a, _b, _c;
        const tabIndexPath = isLocalDebug && !common_1.isConfigUnifyEnabled()
            ? (_b = (_a = ctx.localSettings) === null || _a === void 0 ? void 0 : _a.frontend) === null || _b === void 0 ? void 0 : _b.get(localSettingsConstants_1.LocalSettingsFrontendKeys.TabIndexPath)
            : (_c = ctx.envInfo.state.get(constants_1.PluginNames.FE)) === null || _c === void 0 ? void 0 : _c.get(constants_2.FRONTEND_INDEX_PATH);
        return tabIndexPath;
    }
    getAadClientId(ctx, isLocalDebug) {
        var _a, _b, _c;
        const clientId = isLocalDebug && !common_1.isConfigUnifyEnabled()
            ? (_b = (_a = ctx.localSettings) === null || _a === void 0 ? void 0 : _a.auth) === null || _b === void 0 ? void 0 : _b.get(localSettingsConstants_1.LocalSettingsAuthKeys.ClientId)
            : (_c = ctx.envInfo.state.get(constants_1.PluginNames.AAD)) === null || _c === void 0 ? void 0 : _c.get(constants_1.REMOTE_AAD_ID);
        return clientId;
    }
    getBotId(ctx, isLocalDebug) {
        var _a, _b, _c;
        const botId = isLocalDebug && !common_1.isConfigUnifyEnabled()
            ? (_b = (_a = ctx.localSettings) === null || _a === void 0 ? void 0 : _a.bot) === null || _b === void 0 ? void 0 : _b.get(localSettingsConstants_1.LocalSettingsBotKeys.BotId)
            : (_c = ctx.envInfo.state.get(constants_1.PluginNames.BOT)) === null || _c === void 0 ? void 0 : _c.get(constants_2.BOT_ID);
        return botId;
    }
    getBotDomain(ctx, isLocalDebug) {
        var _a, _b, _c;
        const botDomain = isLocalDebug && !common_1.isConfigUnifyEnabled()
            ? (_b = (_a = ctx.localSettings) === null || _a === void 0 ? void 0 : _a.bot) === null || _b === void 0 ? void 0 : _b.get(localSettingsConstants_1.LocalSettingsBotKeys.BotDomain)
            : (_c = ctx.envInfo.state.get(constants_1.PluginNames.BOT)) === null || _c === void 0 ? void 0 : _c.get(constants_1.BOT_DOMAIN);
        return botDomain;
    }
    getApplicationIdUris(ctx, isLocalDebug) {
        var _a, _b, _c;
        const applicationIdUris = isLocalDebug
            ? (_b = (_a = ctx.localSettings) === null || _a === void 0 ? void 0 : _a.auth) === null || _b === void 0 ? void 0 : _b.get(localSettingsConstants_1.LocalSettingsAuthKeys.ApplicationIdUris)
            : (_c = ctx.envInfo.state.get(constants_1.PluginNames.AAD)) === null || _c === void 0 ? void 0 : _c.get(constants_1.WEB_APPLICATION_INFO_SOURCE);
        return applicationIdUris;
    }
    // TODO: remove isLocalDebug later after merging local and remote configs
    async getTeamsAppId(ctx, isLocalDebug) {
        var _a, _b, _c;
        let teamsAppId = "";
        // User may manually update id in manifest template file, rather than configuration file
        // The id in manifest template file should override configurations
        const manifestResult = await manifestTemplate_1.loadManifest(ctx.root, isLocalDebug);
        if (manifestResult.isOk()) {
            teamsAppId = manifestResult.value.id;
        }
        if (!isUUID_1.default(teamsAppId)) {
            teamsAppId =
                isLocalDebug && !common_1.isConfigUnifyEnabled()
                    ? (_b = (_a = ctx.localSettings) === null || _a === void 0 ? void 0 : _a.teamsApp) === null || _b === void 0 ? void 0 : _b.get(localSettingsConstants_1.LocalSettingsTeamsAppKeys.TeamsAppId)
                    : (_c = ctx.envInfo.state.get(constants_1.PluginNames.APPST)) === null || _c === void 0 ? void 0 : _c.get(constants_2.Constants.TEAMS_APP_ID);
        }
        return teamsAppId;
    }
    /**
     *
     * Refer to AppDefinitionProfile.cs
     */
    async convertToAppDefinition(ctx, appManifest, ignoreIcon) {
        const appDefinition = {
            appName: appManifest.name.short,
            validDomains: appManifest.validDomains,
        };
        appDefinition.showLoadingIndicator = appManifest.showLoadingIndicator;
        appDefinition.isFullScreen = appManifest.isFullScreen;
        appDefinition.appId = appManifest.id;
        appDefinition.appName = appManifest.name.short;
        appDefinition.shortName = appManifest.name.short;
        appDefinition.longName = appManifest.name.full;
        appDefinition.manifestVersion = appManifest.manifestVersion;
        appDefinition.version = appManifest.version;
        appDefinition.packageName = appManifest.packageName;
        appDefinition.accentColor = appManifest.accentColor;
        appDefinition.developerName = appManifest.developer.name;
        appDefinition.mpnId = appManifest.developer.mpnId;
        appDefinition.websiteUrl = appManifest.developer.websiteUrl;
        appDefinition.privacyUrl = appManifest.developer.privacyUrl;
        appDefinition.termsOfUseUrl = appManifest.developer.termsOfUseUrl;
        appDefinition.shortDescription = appManifest.description.short;
        appDefinition.longDescription = appManifest.description.full;
        appDefinition.staticTabs = appManifest.staticTabs;
        appDefinition.configurableTabs = appManifest.configurableTabs;
        appDefinition.bots = utils_1.convertToAppDefinitionBots(appManifest);
        appDefinition.messagingExtensions = utils_1.convertToAppDefinitionMessagingExtensions(appManifest);
        appDefinition.connectors = appManifest.connectors;
        appDefinition.devicePermissions = appManifest.devicePermissions;
        if (appManifest.localizationInfo) {
            let languages = [];
            if (appManifest.localizationInfo.additionalLanguages) {
                try {
                    languages = await Promise.all(appManifest.localizationInfo.additionalLanguages.map(async function (item) {
                        const templateDirectory = await common_1.getAppDirectory(ctx.root);
                        const fileName = `${templateDirectory}/${item.file}`;
                        if (!(await fs.pathExists(fileName))) {
                            throw results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(fileName));
                        }
                        const content = await fs.readJSON(fileName);
                        return {
                            languageTag: item.languageTag,
                            file: content,
                        };
                    }));
                }
                catch (error) {
                    return teamsfx_api_1.err(error);
                }
            }
            appDefinition.localizationInfo = {
                defaultLanguageTag: appManifest.localizationInfo.defaultLanguageTag,
                languages: languages,
            };
        }
        if (appManifest.webApplicationInfo) {
            appDefinition.webApplicationInfoId = appManifest.webApplicationInfo.id;
            appDefinition.webApplicationInfoResource = appManifest.webApplicationInfo.resource;
        }
        appDefinition.activities = appManifest.activities;
        if (!ignoreIcon && appManifest.icons.color) {
            appDefinition.colorIcon = appManifest.icons.color;
        }
        if (!ignoreIcon && appManifest.icons.outline) {
            appDefinition.outlineIcon = appManifest.icons.outline;
        }
        return teamsfx_api_1.ok(appDefinition);
    }
    async createApp(ctx, isLocalDebug) {
        var _a;
        const appDirectory = await common_1.getAppDirectory(ctx.root);
        const status = await fs.lstat(appDirectory);
        if (!status.isDirectory()) {
            throw results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.NotADirectoryError.name, errors_1.AppStudioError.NotADirectoryError.message(appDirectory));
        }
        const manifestResult = await manifestTemplate_1.loadManifest(ctx.root, isLocalDebug);
        if (manifestResult.isErr()) {
            return teamsfx_api_1.err(manifestResult.error);
        }
        const manifest = manifestResult.value;
        manifest.bots = undefined;
        manifest.composeExtensions = undefined;
        if (isLocalDebug || !isUUID_1.default(manifest.id)) {
            manifest.id = uuid_1.v4();
        }
        const colorFile = `${appDirectory}/${manifest.icons.color}`;
        if (!(await fs.pathExists(colorFile))) {
            throw results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(colorFile));
        }
        const outlineFile = `${appDirectory}/${manifest.icons.outline}`;
        if (!(await fs.pathExists(outlineFile))) {
            throw results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(outlineFile));
        }
        const zip = new adm_zip_1.default();
        zip.addFile(constants_2.Constants.MANIFEST_FILE, Buffer.from(JSON.stringify(manifest)));
        zip.addLocalFile(colorFile);
        zip.addLocalFile(outlineFile);
        const archivedFile = zip.toBuffer();
        const appStudioToken = await ((_a = ctx === null || ctx === void 0 ? void 0 : ctx.appStudioToken) === null || _a === void 0 ? void 0 : _a.getAccessToken());
        try {
            const appDefinition = await appStudio_1.AppStudioClient.createApp(archivedFile, appStudioToken, ctx.logProvider);
            return teamsfx_api_1.ok(appDefinition);
        }
        catch (e) {
            return teamsfx_api_1.err(isLocalDebug
                ? results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.LocalAppIdCreateFailedError.name, errors_1.AppStudioError.LocalAppIdCreateFailedError.message(e))
                : results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.RemoteAppIdCreateFailedError.name, errors_1.AppStudioError.RemoteAppIdCreateFailedError.message(e)));
        }
    }
    async updateApp(ctx, appDefinition, appStudioToken, isLocalDebug, createIfNotExist, appDirectory, teamsAppId, logProvider) {
        var _a;
        if (appStudioToken === undefined || appStudioToken.length === 0) {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.SystemError(constants_1.SolutionError.NoAppStudioToken, [
                localizeUtils_1.getDefaultString("error.appstudio.noAppStudioToken"),
                localizeUtils_1.getLocalizedString("error.appstudio.noAppStudioToken"),
            ]));
        }
        if (createIfNotExist) {
            const appDef = await this.createApp(ctx, isLocalDebug);
            if (appDef.isErr()) {
                return teamsfx_api_1.err(appDef.error);
            }
            if (!appDef.value.teamsAppId) {
                return teamsfx_api_1.err(isLocalDebug
                    ? results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.LocalAppIdCreateFailedError.name, errors_1.AppStudioError.LocalAppIdCreateFailedError.message())
                    : results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.RemoteAppIdCreateFailedError.name, errors_1.AppStudioError.RemoteAppIdCreateFailedError.message()));
            }
            teamsAppId = appDef.value.teamsAppId;
            appDefinition.outlineIcon = appDef.value.outlineIcon;
            appDefinition.colorIcon = appDef.value.colorIcon;
        }
        const colorIconContent = appDirectory && appDefinition.colorIcon && !appDefinition.colorIcon.startsWith("https://")
            ? (await fs.readFile(`${appDirectory}/${appDefinition.colorIcon}`)).toString("base64")
            : undefined;
        const outlineIconContent = appDirectory && appDefinition.outlineIcon && !appDefinition.outlineIcon.startsWith("https://")
            ? (await fs.readFile(`${appDirectory}/${appDefinition.outlineIcon}`)).toString("base64")
            : undefined;
        appDefinition.appId = teamsAppId;
        try {
            const app = await appStudio_1.AppStudioClient.updateApp(teamsAppId, appDefinition, appStudioToken, logProvider, colorIconContent, outlineIconContent);
            if (app.updatedAt && (!isLocalDebug || common_1.isConfigUnifyEnabled())) {
                const time = new Date(app.updatedAt).getTime();
                (_a = ctx.envInfo.state.get(constants_1.PluginNames.APPST)) === null || _a === void 0 ? void 0 : _a.set(constants_2.Constants.TEAMS_APP_UPDATED_AT, time);
            }
            return teamsfx_api_1.ok(teamsAppId);
        }
        catch (e) {
            if (e instanceof Error) {
                return teamsfx_api_1.err(isLocalDebug
                    ? results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.LocalAppIdUpdateFailedError.name, errors_1.AppStudioError.LocalAppIdUpdateFailedError.message(e))
                    : results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.RemoteAppIdUpdateFailedError.name, errors_1.AppStudioError.RemoteAppIdUpdateFailedError.message(e)));
            }
            throw e;
        }
    }
    async validateManifestAgainstSchema(manifest) {
        if (manifest.$schema) {
            try {
                const result = await teamsfx_api_1.ManifestUtil.validateManifest(manifest);
                return teamsfx_api_1.ok(result);
            }
            catch (e) {
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, errors_1.AppStudioError.ValidationFailedError.message([
                    localizeUtils_1.getLocalizedString("error.appstudio.validateFetchSchemaFailed", manifest.$schema, e.message),
                ]), constants_3.HelpLinks.WhyNeedProvision));
            }
        }
        else {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, errors_1.AppStudioError.ValidationFailedError.message([
                localizeUtils_1.getLocalizedString("error.appstudio.validateSchemaNotDefined"),
            ]), constants_3.HelpLinks.WhyNeedProvision));
        }
    }
    async getAppDefinitionAndManifest(ctx, isLocalDebug) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
        const { tabEndpoint, tabDomain, tabIndexPath, aadId, botDomain, botId, webApplicationInfoResource, teamsAppId, } = await this.getConfigForCreatingManifest(ctx, isLocalDebug && !common_1.isConfigUnifyEnabled());
        const isProvisionSucceeded = !!((_a = ctx.envInfo.state
            .get("solution")) === null || _a === void 0 ? void 0 : _a.get(constants_1.SOLUTION_PROVISION_SUCCEEDED));
        const validDomains = [];
        if (tabDomain) {
            validDomains.push(tabDomain);
        }
        if (tabEndpoint && isLocalDebug) {
            validDomains.push(tabEndpoint.slice(8));
        }
        if (botId) {
            if (!botDomain) {
                if (isLocalDebug && !common_1.isConfigUnifyEnabled()) {
                    return teamsfx_api_1.err(results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.GetLocalDebugConfigFailedError.name, errors_1.AppStudioError.GetLocalDebugConfigFailedError.message(new Error(localizeUtils_1.getLocalizedString("plugins.appstudio.dataRequired", constants_1.LOCAL_DEBUG_BOT_DOMAIN)))));
                }
                else {
                    return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.GetRemoteConfigFailedError.name, errors_1.AppStudioError.GetRemoteConfigFailedError.message(localizeUtils_1.getLocalizedString("plugins.appstudio.dataRequired", constants_1.BOT_DOMAIN), isProvisionSucceeded), constants_3.HelpLinks.WhyNeedProvision));
                }
            }
            else {
                validDomains.push(botDomain);
            }
        }
        const manifestResult = await manifestTemplate_1.loadManifest(ctx.root, isLocalDebug);
        if (manifestResult.isErr()) {
            return teamsfx_api_1.err(manifestResult.error);
        }
        let manifestString = JSON.stringify(manifestResult.value);
        // Bot only project, without frontend hosting
        let endpoint = tabEndpoint;
        let indexPath = tabIndexPath;
        let hasFrontend = false;
        if (common_1.isConfigUnifyEnabled()) {
            const capabilities = await manifestTemplate_1.getCapabilities(ctx.root);
            if (capabilities.isErr()) {
                return teamsfx_api_1.err(capabilities.error);
            }
            hasFrontend =
                capabilities.value.includes("staticTab") || capabilities.value.includes("configurableTab");
        }
        else {
            const solutionSettings = (_b = ctx.projectSettings) === null || _b === void 0 ? void 0 : _b.solutionSettings;
            hasFrontend = solutionSettings.capabilities.includes(question_1.TabOptionItem.id);
        }
        if (!endpoint && !hasFrontend) {
            endpoint = constants_2.DEFAULT_DEVELOPER_WEBSITE_URL;
            indexPath = "";
        }
        const customizedKeys = utils_1.getCustomizedKeys("", JSON.parse(manifestString));
        this.commonProperties = {
            [telemetry_1.TelemetryPropertyKey.customizedKeys]: JSON.stringify(customizedKeys),
        };
        const view = {
            config: ctx.envInfo.config,
            state: {
                "fx-resource-frontend-hosting": {
                    endpoint: endpoint !== null && endpoint !== void 0 ? endpoint : "{{{state.fx-resource-frontend-hosting.endpoint}}}",
                    indexPath: indexPath !== null && indexPath !== void 0 ? indexPath : "{{{state.fx-resource-frontend-hosting.indexPath}}}",
                },
                "fx-resource-aad-app-for-teams": {
                    clientId: aadId !== null && aadId !== void 0 ? aadId : "{{state.fx-resource-aad-app-for-teams.clientId}}",
                    applicationIdUris: webApplicationInfoResource !== null && webApplicationInfoResource !== void 0 ? webApplicationInfoResource : "{{{state.fx-resource-aad-app-for-teams.applicationIdUris}}}",
                },
                "fx-resource-appstudio": {
                    teamsAppId: teamsAppId !== null && teamsAppId !== void 0 ? teamsAppId : "{{state.fx-resource-appstudio.teamsAppId}}",
                },
                "fx-resource-bot": {
                    botId: botId !== null && botId !== void 0 ? botId : "{{state.fx-resource-bot.botId}}",
                },
            },
            localSettings: {
                frontend: {
                    tabEndpoint: endpoint ? endpoint : "{{{localSettings.frontend.tabEndpoint}}}",
                    tabIndexPath: indexPath !== null && indexPath !== void 0 ? indexPath : "{{{localSettings.frontend.tabIndexPath}}}",
                },
                auth: {
                    clientId: common_1.isConfigUnifyEnabled() && aadId
                        ? aadId
                        : ((_d = (_c = ctx.localSettings) === null || _c === void 0 ? void 0 : _c.auth) === null || _d === void 0 ? void 0 : _d.get(localSettingsConstants_1.LocalSettingsAuthKeys.ClientId))
                            ? (_f = (_e = ctx.localSettings) === null || _e === void 0 ? void 0 : _e.auth) === null || _f === void 0 ? void 0 : _f.get(localSettingsConstants_1.LocalSettingsAuthKeys.ClientId)
                            : "{{localSettings.auth.clientId}}",
                    applicationIdUris: common_1.isConfigUnifyEnabled() && webApplicationInfoResource
                        ? webApplicationInfoResource
                        : ((_h = (_g = ctx.localSettings) === null || _g === void 0 ? void 0 : _g.auth) === null || _h === void 0 ? void 0 : _h.get(localSettingsConstants_1.LocalSettingsAuthKeys.ApplicationIdUris))
                            ? (_k = (_j = ctx.localSettings) === null || _j === void 0 ? void 0 : _j.auth) === null || _k === void 0 ? void 0 : _k.get(localSettingsConstants_1.LocalSettingsAuthKeys.ApplicationIdUris)
                            : "{{{localSettings.auth.applicationIdUris}}}",
                },
                teamsApp: {
                    teamsAppId: common_1.isConfigUnifyEnabled() && teamsAppId
                        ? teamsAppId
                        : ((_m = (_l = ctx.localSettings) === null || _l === void 0 ? void 0 : _l.teamsApp) === null || _m === void 0 ? void 0 : _m.get(localSettingsConstants_1.LocalSettingsTeamsAppKeys.TeamsAppId))
                            ? (_p = (_o = ctx.localSettings) === null || _o === void 0 ? void 0 : _o.teamsApp) === null || _p === void 0 ? void 0 : _p.get(localSettingsConstants_1.LocalSettingsTeamsAppKeys.TeamsAppId)
                            : "{{localSettings.teamsApp.teamsAppId}}",
                },
                bot: {
                    botId: common_1.isConfigUnifyEnabled() && botId
                        ? botId
                        : ((_r = (_q = ctx.localSettings) === null || _q === void 0 ? void 0 : _q.bot) === null || _r === void 0 ? void 0 : _r.get(localSettingsConstants_1.LocalSettingsBotKeys.BotId))
                            ? (_t = (_s = ctx.localSettings) === null || _s === void 0 ? void 0 : _s.bot) === null || _t === void 0 ? void 0 : _t.get(localSettingsConstants_1.LocalSettingsBotKeys.BotId)
                            : "{{localSettings.bot.botId}}",
                },
            },
        };
        mustache_1.default.escape = (value) => value;
        manifestString = mustache_1.default.render(manifestString, view);
        const tokens = [
            ...new Set(mustache_1.default.parse(manifestString)
                .filter((x) => {
                if (common_1.isConfigUnifyEnabled()) {
                    // TODO: update local check
                    return (x[0] != "text" &&
                        (ctx.envInfo.envName !== environment_1.environmentManager.getLocalEnvName() ||
                            x[1] != "state.fx-resource-appstudio.teamsAppId"));
                }
                else {
                    return x[0] != "text" && x[1] != "localSettings.teamsApp.teamsAppId";
                }
            })
                .map((x) => x[1])),
        ];
        if (tokens.length > 0) {
            if (isLocalDebug) {
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.GetLocalDebugConfigFailedError.name, errors_1.AppStudioError.GetLocalDebugConfigFailedError.message(new Error(localizeUtils_1.getLocalizedString("plugins.appstudio.dataRequired", tokens.join(","))))));
            }
            else {
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.GetRemoteConfigFailedError.name, errors_1.AppStudioError.GetRemoteConfigFailedError.message(localizeUtils_1.getLocalizedString("plugins.appstudio.dataRequired", tokens.join(",")), isProvisionSucceeded), constants_3.HelpLinks.WhyNeedProvision));
            }
        }
        let updatedManifest;
        try {
            updatedManifest = JSON.parse(manifestString);
        }
        catch (error) {
            if (error.stack && error.stack.startsWith("SyntaxError")) {
                // teams app id in userData may be updated by user, result to invalid manifest
                const reg = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;
                const result = teamsAppId.match(reg);
                if (!result) {
                    return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.InvalidManifestError.name, errors_1.AppStudioError.InvalidManifestError.message(error, "teamsAppId"), undefined, error.stack));
                }
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.InvalidManifestError.name, errors_1.AppStudioError.InvalidManifestError.message(error), undefined, error.stack));
            }
            else {
                return teamsfx_api_1.err(error);
            }
        }
        for (const domain of validDomains) {
            (_u = updatedManifest.validDomains) === null || _u === void 0 ? void 0 : _u.push(domain);
        }
        const appDefinitionRes = await this.convertToAppDefinition(ctx, updatedManifest, false);
        if (appDefinitionRes.isErr()) {
            return teamsfx_api_1.err(appDefinitionRes.error);
        }
        const appDefinition = appDefinitionRes.value;
        return teamsfx_api_1.ok([appDefinition, updatedManifest]);
    }
    async getSPFxManifest(ctx, isLocalDebug) {
        var _a, _b;
        const manifestResult = await manifestTemplate_1.loadManifest(ctx.root, isLocalDebug);
        if (manifestResult.isErr()) {
            throw manifestResult.error;
        }
        let manifestString = JSON.stringify(manifestResult.value);
        const view = {
            config: ctx.envInfo.config,
            state: {
                "fx-resource-appstudio": {
                    teamsAppId: await this.getTeamsAppId(ctx, isLocalDebug),
                },
            },
            localSettings: {
                teamsApp: {
                    teamsAppId: (_b = (_a = ctx.localSettings) === null || _a === void 0 ? void 0 : _a.teamsApp) === null || _b === void 0 ? void 0 : _b.get(localSettingsConstants_1.LocalSettingsTeamsAppKeys.TeamsAppId),
                },
            },
        };
        mustache_1.default.escape = (value) => value;
        manifestString = mustache_1.default.render(manifestString, view);
        return manifestString;
    }
}
exports.AppStudioPluginImpl = AppStudioPluginImpl;
async function createLocalManifest(appName, hasFrontend, hasBot, hasMessageExtension, isSPFx, hasAad = true, isM365 = false) {
    let name = appName;
    const suffix = "-local-debug";
    if (suffix.length + appName.length <= constants_2.TEAMS_APP_SHORT_NAME_MAX_LENGTH) {
        name = name + suffix;
    }
    if (isSPFx) {
        const templateManifestFolder = path_1.default.join(folder_1.getTemplatesFolder(), "plugins", "resource", "spfx");
        const localManifestFile = path_1.default.resolve(templateManifestFolder, `./solution/${constants_2.MANIFEST_LOCAL}`);
        let manifestString = (await fs.readFile(localManifestFile)).toString();
        manifestString = utils_1.replaceConfigValue(manifestString, "appName", name);
        const manifest = JSON.parse(manifestString);
        return manifest;
    }
    else {
        let manifestString = constants_2.TEAMS_APP_MANIFEST_TEMPLATE_LOCAL_DEBUG_V3;
        manifestString = utils_1.replaceConfigValue(manifestString, "appName", name);
        const manifest = JSON.parse(manifestString);
        if (hasAad) {
            manifest.webApplicationInfo = constants_2.WEB_APPLICATION_INFO_LOCAL_DEBUG;
        }
        if (hasFrontend) {
            manifest.staticTabs = constants_2.STATIC_TABS_TPL_LOCAL_DEBUG;
            if (!isM365) {
                manifest.configurableTabs = constants_2.CONFIGURABLE_TABS_TPL_LOCAL_DEBUG;
            }
        }
        if (hasBot) {
            manifest.bots = constants_2.BOTS_TPL_LOCAL_DEBUG;
        }
        if (hasMessageExtension) {
            manifest.composeExtensions = constants_2.COMPOSE_EXTENSIONS_TPL_LOCAL_DEBUG;
        }
        if (isM365) {
            manifest.$schema = constants_2.M365_SCHEMA;
            manifest.manifestVersion = constants_2.M365_MANIFEST_VERSION;
        }
        return manifest;
    }
}
exports.createLocalManifest = createLocalManifest;
async function createManifest(appName, hasFrontend, hasBot, hasNotificationBot, hasCommandAndResponseBot, hasMessageExtension, isSPFx, hasAad = true, isM365 = false) {
    if (!hasBot && !hasMessageExtension && !hasFrontend && !hasAad) {
        throw new Error(`Invalid capability`);
    }
    if (!isSPFx || hasBot || hasMessageExtension || hasAad) {
        const manifestString = constants_2.TEAMS_APP_MANIFEST_TEMPLATE_V3;
        const manifest = JSON.parse(manifestString);
        if (hasAad) {
            manifest.webApplicationInfo = constants_2.WEB_APPLICATION_INFO_MULTI_ENV;
        }
        if (hasFrontend) {
            manifest.staticTabs = constants_2.STATIC_TABS_TPL_FOR_MULTI_ENV;
            if (!isM365) {
                manifest.configurableTabs = constants_2.CONFIGURABLE_TABS_TPL_FOR_MULTI_ENV;
            }
        }
        if (hasBot) {
            if (hasCommandAndResponseBot) {
                manifest.bots = constants_2.BOTS_TPL_FOR_COMMAND_AND_RESPONSE;
            }
            else if (hasNotificationBot) {
                manifest.bots = constants_2.BOTS_TPL_FOR_NOTIFICATION;
            }
            else {
                manifest.bots = constants_2.BOTS_TPL_FOR_MULTI_ENV;
            }
        }
        if (hasMessageExtension) {
            manifest.composeExtensions = isM365
                ? constants_2.COMPOSE_EXTENSIONS_TPL_FOR_MULTI_ENV_M365
                : constants_2.COMPOSE_EXTENSIONS_TPL_FOR_MULTI_ENV;
        }
        if (isM365) {
            manifest.$schema = constants_2.M365_SCHEMA;
            manifest.manifestVersion = constants_2.M365_MANIFEST_VERSION;
        }
        return manifest;
    }
    return undefined;
}
exports.createManifest = createManifest;
//# sourceMappingURL=plugin.js.map