"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.AppStudioPluginImpl = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs = tslib_1.__importStar(require("fs-extra"));
const path_1 = tslib_1.__importDefault(require("path"));
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const uuid_1 = require("uuid");
const isUUID_1 = tslib_1.__importDefault(require("validator/lib/isUUID"));
const appStudio_1 = require("../appStudio");
const results_1 = require("../results");
const errors_1 = require("../errors");
const common_1 = require("../../../../common");
const constants_1 = require("../constants");
const utils_1 = require("../utils/utils");
const manifestTemplate_1 = require("../manifestTemplate");
class AppStudioPluginImpl {
    async createOrUpdateTeamsApp(ctx, inputs, envInfo, tokenProvider) {
        var _a, _b, _c, _d;
        let archivedFile;
        // User provided zip file
        if (inputs.appPackagePath) {
            if (await fs.pathExists(inputs.appPackagePath)) {
                archivedFile = await fs.readFile(inputs.appPackagePath);
            }
            else {
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(inputs.appPackagePath)));
            }
        }
        else {
            const buildPackage = await this.buildTeamsAppPackage(inputs.projectPath, envInfo);
            if (buildPackage.isErr()) {
                return teamsfx_api_1.err(buildPackage.error);
            }
            archivedFile = await fs.readFile(buildPackage.value);
        }
        const appStudioToken = await tokenProvider.appStudioToken.getAccessToken();
        try {
            const appDefinition = await appStudio_1.AppStudioClient.createApp(archivedFile, appStudioToken, ctx.logProvider);
            (_a = ctx.userInteraction) === null || _a === void 0 ? void 0 : _a.showMessage("info", `Teams app created: ${appDefinition.teamsAppId}`, false);
            return teamsfx_api_1.ok(appDefinition.teamsAppId);
        }
        catch (e) {
            // Teams app already exists, will update it
            if (e.name === 409 || e.name === 422) {
                const zipEntries = new adm_zip_1.default(archivedFile).getEntries();
                const manifestFile = zipEntries.find((x) => x.entryName === constants_1.Constants.MANIFEST_FILE);
                if (!manifestFile) {
                    return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(constants_1.Constants.MANIFEST_FILE)));
                }
                const manifestString = manifestFile.getData().toString();
                const manifest = JSON.parse(manifestString);
                const appDefinition = utils_1.convertToAppDefinition(manifest);
                const colorIconContent = (_b = zipEntries
                    .find((x) => x.entryName === manifest.icons.color)) === null || _b === void 0 ? void 0 : _b.getData().toString("base64");
                const outlineIconContent = (_c = zipEntries
                    .find((x) => x.entryName === manifest.icons.outline)) === null || _c === void 0 ? void 0 : _c.getData().toString("base64");
                try {
                    const app = await appStudio_1.AppStudioClient.updateApp(manifest.id, appDefinition, appStudioToken, undefined, colorIconContent, outlineIconContent);
                    (_d = ctx.userInteraction) === null || _d === void 0 ? void 0 : _d.showMessage("info", `Teams app updated: ${appDefinition.appId}`, false);
                    return teamsfx_api_1.ok(app.teamsAppId);
                }
                catch (e) {
                    return teamsfx_api_1.err(results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.TeamsAppUpdateFailedError.name, errors_1.AppStudioError.TeamsAppUpdateFailedError.message(manifest.id)));
                }
            }
            else {
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.TeamsAppCreateFailedError.name, errors_1.AppStudioError.TeamsAppCreateFailedError.message(e)));
            }
        }
    }
    async publishTeamsApp(ctx, inputs, envInfo, tokenProvider) {
        var _a;
        let archivedFile;
        // User provided zip file
        if (inputs.appPackagePath) {
            if (await fs.pathExists(inputs.appPackagePath)) {
                archivedFile = await fs.readFile(inputs.appPackagePath);
            }
            else {
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(inputs.appPackagePath)));
            }
        }
        else {
            const buildPackage = await this.buildTeamsAppPackage(inputs.projectPath, envInfo);
            if (buildPackage.isErr()) {
                return teamsfx_api_1.err(buildPackage.error);
            }
            archivedFile = await fs.readFile(buildPackage.value);
        }
        const zipEntries = new adm_zip_1.default(archivedFile).getEntries();
        const manifestFile = zipEntries.find((x) => x.entryName === constants_1.Constants.MANIFEST_FILE);
        if (!manifestFile) {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(constants_1.Constants.MANIFEST_FILE)));
        }
        const manifestString = manifestFile.getData().toString();
        const manifest = JSON.parse(manifestString);
        // manifest.id === externalID
        const appStudioToken = await (tokenProvider === null || tokenProvider === void 0 ? void 0 : tokenProvider.getAccessToken());
        const existApp = await appStudio_1.AppStudioClient.getAppByTeamsAppId(manifest.id, appStudioToken);
        if (existApp) {
            let executePublishUpdate = false;
            let description = `The app ${existApp.displayName} has already been submitted to tenant App Catalog.\nStatus: ${existApp.publishingState}\n`;
            if (existApp.lastModifiedDateTime) {
                description =
                    description + `Last Modified: ${(_a = existApp.lastModifiedDateTime) === null || _a === void 0 ? void 0 : _a.toLocaleString()}\n`;
            }
            description = description + "Do you want to submit a new update?";
            const res = await ctx.userInteraction.showMessage("warn", description, true, "Confirm");
            if ((res === null || res === void 0 ? void 0 : res.isOk()) && res.value === "Confirm")
                executePublishUpdate = true;
            if (executePublishUpdate) {
                const appId = await appStudio_1.AppStudioClient.publishTeamsAppUpdate(manifest.id, archivedFile, appStudioToken);
                return teamsfx_api_1.ok({ publishedAppId: appId, appName: manifest.name.short, update: true });
            }
            else {
                throw results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.TeamsAppPublishCancelError.name, errors_1.AppStudioError.TeamsAppPublishCancelError.message(manifest.name.short));
            }
        }
        else {
            const appId = await appStudio_1.AppStudioClient.publishTeamsApp(manifest.id, archivedFile, appStudioToken);
            return teamsfx_api_1.ok({ publishedAppId: appId, appName: manifest.name.short, update: false });
        }
    }
    /**
     * Build appPackage.{envName}.zip
     * @returns Path for built Teams app package
     */
    async buildTeamsAppPackage(projectPath, envInfo) {
        const buildFolderPath = `${projectPath}/${teamsfx_api_1.BuildFolderName}/${teamsfx_api_1.AppPackageFolderName}`;
        await fs.ensureDir(buildFolderPath);
        const appDefinitionRes = await this.getAppDefinitionAndManifest(projectPath, envInfo);
        if (appDefinitionRes.isErr()) {
            return teamsfx_api_1.err(appDefinitionRes.error);
        }
        const manifest = appDefinitionRes.value[1];
        if (!isUUID_1.default(manifest.id)) {
            manifest.id = uuid_1.v4();
        }
        // manifest.bots = undefined;
        // manifest.composeExtensions = undefined;
        const appDirectory = await common_1.getAppDirectory(projectPath);
        const colorFile = `${appDirectory}/${manifest.icons.color}`;
        if (!(await fs.pathExists(colorFile))) {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(colorFile)));
        }
        const outlineFile = `${appDirectory}/${manifest.icons.outline}`;
        if (!(await fs.pathExists(outlineFile))) {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(outlineFile)));
        }
        const zip = new adm_zip_1.default();
        zip.addFile(constants_1.Constants.MANIFEST_FILE, Buffer.from(JSON.stringify(manifest, null, 4)));
        // outline.png & color.png, relative path
        let dir = path_1.default.dirname(manifest.icons.color);
        zip.addLocalFile(colorFile, dir === "." ? "" : dir);
        dir = path_1.default.dirname(manifest.icons.outline);
        zip.addLocalFile(outlineFile, dir === "." ? "" : dir);
        const zipFileName = `${buildFolderPath}/appPackage.${envInfo.envName}.zip`;
        zip.writeZip(zipFileName);
        const manifestFileName = `${buildFolderPath}/manifest.${envInfo.envName}.json`;
        if (await fs.pathExists(manifestFileName)) {
            await fs.chmod(manifestFileName, 0o777);
        }
        await fs.writeFile(manifestFileName, JSON.stringify(manifest, null, 4));
        await fs.chmod(manifestFileName, 0o444);
        return teamsfx_api_1.ok(zipFileName);
    }
    /**
     * Validate manifest
     * @returns an array of validation error strings
     */
    async validateManifest(manifest) {
        // TODO: import teamsfx-manifest package
        return teamsfx_api_1.ok([]);
    }
    async getAppDefinitionAndManifest(projectPath, envInfo) {
        // Read template
        const manifestTemplateRes = await manifestTemplate_1.loadManifest(projectPath, false);
        if (manifestTemplateRes.isErr()) {
            return teamsfx_api_1.err(manifestTemplateRes.error);
        }
        let manifestString = JSON.stringify(manifestTemplateRes.value);
        // Render mustache template with state and config
        const view = {
            config: envInfo.config,
            state: envInfo.state,
        };
        manifestString = common_1.compileHandlebarsTemplateString(manifestString, view);
        const manifest = JSON.parse(manifestString);
        const appDefinition = utils_1.convertToAppDefinition(manifest);
        return teamsfx_api_1.ok([appDefinition, manifest]);
    }
}
exports.AppStudioPluginImpl = AppStudioPluginImpl;
//# sourceMappingURL=plugin.js.map