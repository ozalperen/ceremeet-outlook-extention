"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.EnvManager = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
require("reflect-metadata");
const typedi_1 = require("typedi");
const environment_1 = require("../core/environment");
let EnvManager = class EnvManager {
    constructor() {
        this.name = "env-manager";
        // read(
        //   context: ContextV3,
        //   inputs: InputsWithProjectPath
        // ): MaybePromise<Result<Action | undefined, FxError>> {
        //   const action: Action = {
        //     type: "function",
        //     name: "env-manager.read",
        //     plan: (context: ContextV3, inputs: InputsWithProjectPath) => {
        //       return ok([]);
        //     },
        //     execute: async (context: ContextV3, inputs: InputsWithProjectPath) => {
        //       const envName = inputs.envName;
        //       const envInfoRes = await loadEnvInfoV3(inputs, context.projectSetting, envName);
        //       if (envInfoRes.isErr()) return err(envInfoRes.error);
        //       context.envInfo = envInfoRes.value;
        //       return ok([]);
        //     },
        //   };
        //   return ok(action);
        // }
        // write(
        //   context: ContextV3,
        //   inputs: InputsWithProjectPath
        // ): MaybePromise<Result<Action | undefined, FxError>> {
        //   const action: Action = {
        //     type: "function",
        //     name: "env-manager.write",
        //     plan: (context: ContextV3, inputs: InputsWithProjectPath) => {
        //       if (context.envInfo?.state) {
        //         const envStatePath = path.join(
        //           inputs.projectPath,
        //           "states",
        //           `state.${context.envInfo.envName}.json`
        //         );
        //         const userDataPath = path.join(
        //           inputs.projectPath,
        //           "states",
        //           `${context.envInfo.envName}.userdata`
        //         );
        //         return ok(createFilesEffects([envStatePath, userDataPath], "replace", "env state"));
        //       }
        //       return ok([]);
        //     },
        //     execute: async (context: ContextV3, inputs: InputsWithProjectPath) => {
        //       if (context.envInfo?.state) {
        //         const envStatePath = path.join(
        //           inputs.projectPath,
        //           "states",
        //           `state.${context.envInfo.envName}.json`
        //         );
        //         const userDataPath = path.join(
        //           inputs.projectPath,
        //           "states",
        //           `${context.envInfo.envName}.userdata`
        //         );
        //         const effects = createFilesEffects([envStatePath, userDataPath], "replace", "env state");
        //         for (const key of Object.keys(context.envInfo.state)) {
        //           if (key !== "solution") {
        //             const cloudResource = Container.get(key) as CloudResource;
        //             if (cloudResource.finalOutputKeys) {
        //               const config = context.envInfo.state[key];
        //               for (const configKey of Object.keys(config)) {
        //                 if (!cloudResource.finalOutputKeys.includes(configKey)) {
        //                   delete config[configKey];
        //                 }
        //               }
        //             }
        //           }
        //         }
        //         const writeEnvStateRes = await environmentManager.writeEnvState(
        //           context.envInfo.state,
        //           inputs.projectPath,
        //           new LocalCrypto(context.projectSetting.projectId),
        //           context.envInfo.envName,
        //           true
        //         );
        //         if (writeEnvStateRes.isErr()) return err(writeEnvStateRes.error);
        //         return ok(effects);
        //       }
        //       return ok([]);
        //     },
        //   };
        //   return ok(action);
        // }
    }
    create(context, inputs) {
        const action = {
            name: "env-manager.create",
            type: "function",
            plan: async (context, inputs) => {
                const envName = inputs.envName || environment_1.environmentManager.getDefaultEnvName();
                const envConfigPath = path.join(inputs.projectPath, ".fx", "configs", `config.${envName}.json`);
                return teamsfx_api_1.ok([
                    {
                        type: "file",
                        filePath: envConfigPath,
                        operate: "create",
                        remarks: "env config",
                    },
                ]);
            },
            execute: async (context, inputs) => {
                const envName = inputs.envName || environment_1.environmentManager.getDefaultEnvName();
                const envConfig = environment_1.environmentManager.newEnvConfigData(context.projectSetting.appName, undefined);
                const envConfigPath = path.join(inputs.projectPath, ".fx", "configs", `config.${envName}.json`);
                await fs_extra_1.default.ensureDir(path.join(inputs.projectPath, ".fx", "configs"));
                await fs_extra_1.default.writeFile(envConfigPath, JSON.stringify(envConfig, null, 4));
                return teamsfx_api_1.ok([
                    {
                        type: "file",
                        filePath: envConfigPath,
                        operate: "create",
                        remarks: "env config",
                    },
                ]);
            },
        };
        return teamsfx_api_1.ok(action);
    }
};
EnvManager = tslib_1.__decorate([
    typedi_1.Service("env-manager")
], EnvManager);
exports.EnvManager = EnvManager;
//# sourceMappingURL=envManager.js.map